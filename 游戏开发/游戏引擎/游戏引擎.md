# 概论

## 引擎分层

### 平台层

- **统一封装API**：各平台的API不同（操作系统、渲染API、发布渠道），需要将其封装为统一的API，然后在此基础上继续写核心功能

### 核心层

- **内存管理**
- **进程管理**
- **工具库**：工具函数，数据结构等，追求极致效率

### 资源层

- **资源导入**：处理导入引擎的各种类型的文件，形成**Asset**
  - 图像、模型、材质、音频这类文件有多种格式，导入后形成统一的有限种格式（处理效率更高，消除传输障碍）
  - 一些其他类型的文件不作处理（引擎往往无法直接使用这些文件，可能要依赖第三方库）

- **资源管理**：查找、查看资源，记录Asset间的引用关系等
  - 一种资源索引方式是GUID，GUID与Asset一一对应（由导入时间决定，一旦导入，不因任何事件改变）
  - Asset间的引用关系（可以用GUID表示引用了哪个Asset）可以用XML文件记录（Unity中，引用信息直接记录在场景、prefab等类型的文件中）；记录了引用关系的文件，也可以视为Asset


### 功能层

- 动画系统
- 物理系统
- 渲染系统
- 声音系统
- UI
- 脚本

### 工具层

- **编辑器**：使修改游戏内容更加方便的工具，对程序以外的的开发人员意义更大

### 第三方库

- 可能涉及上述的各层（主要是功能层）
- 第三方库与引擎有不同的交互方式：
  - 直接作为源代码或静态库参与引擎的编译
  - 作为动态库在运行时发挥作用
  - 间接地通过硬盘上的文件交互

## 信息交互

- 一个对象不会直接控制另一个对象的具体行为，顶多是指示对方执行某个行为，很多情况下，中间会插入一个中介，两方都只获取中介，这个中介通常被成为事件系统
- 一些工作会被分配到多个线程进行，但如果对执行顺序有要求的话，就不能完全在多线程进行。比如碰撞检测，多个线程分别处理一部分游戏物体，但仅仅记录碰撞信息，之后的某个时机再结算所有碰撞反馈，结算碰撞反馈时，确保每个物体的结算在一个线程上进行即可

# 内存管理

## 依赖关系和生命周期

游戏对象间存在广泛的依赖，需要控制各个游戏对象的激活、销毁顺序。游戏中一些公共服务，通常用单例实现，它们间也会存在依赖。最简单的方法是人为控制各系统的启动和关闭。此外，可以用数字规定每个服务的激活顺序(借助优先队列)；也可以定义服务间的依赖图，由此确定激活顺序。

## 内存分配器

合适的情况下，使用堆栈分配器和池分配器比直接动态分配内存好。

### 堆栈分配器

只能连续地按顺序往一个方向分配一块内存，只能连续地倒回来释放内存。不会产生内存碎片，但限制了内存中这些对象的构造、析构顺序。

### 池分配器

将内存划分为若干大小相同的块，用链表连接。取出时，存放游戏数据；为取出时，存放下一个节点的地址。仅能用于大小一致（或不超过某个值）的一堆对象，用池分配器为它们分配内存时不需要考虑内存碎片。

### 碎片清理

动态内存分配大小不定、地址随机，会产生内存碎片，需要进行碎片清理，即将移动内存块，使未分配内存聚集成一块。移动内存要借助**句柄**(hanlde)。句柄相当于指针的指针，移动内存块时，把数据拷贝到新的区域，更新指针，此过程称为指针重定位(**relocation**)。而句柄没有变，通过句柄获取新区域的地址。

## 缓存

缓存的读写速度块，成本高，空间小。现代计算机上缓存分多级，速度越快，空间越小。

### 缓存命中

需要取得一个数据时，先逐级在缓存中寻找，找不到再去内存中寻找。在缓存中找到数据称为**缓存命中**。

### 模型

![v2-f515f558e7a516928a79313a8ffe28a4_720w](v2-f515f558e7a516928a79313a8ffe28a4_720w.jpg)

- 缓存分**S = 2^s**级，每级缓存分**E**行，每行有1bit有效位，**t**bit标记，**B = 2^b**Byte数据。缓存从内存（或低一级缓存）中读取数据时，总是一次读取**B**Byte数据（而且是地址对齐的）。


- 读数据过程（假设只有一级缓存，每组只有一行，每次取1Byte数据）：

  1. 读取数据时，输入一个地址，地址被分为3部分：高t位为标记，中间s位为组索引，后b位为偏移量
  2. 根据组索引确定数据可能在哪一组中，访问该组的行
  3. 如果有效位为0，则缓存不命中，将该地址所在的一块大小为**B**byte的数据写入缓存，将标记设为地址的高**s**位
  4. 如果有效位为1，比较标记和地址的高**s**位是否相同
  5. 如果不相同，缓存不命中，将该地址所在的一块大小为**B**byte的数据写入缓存（覆盖原数据），将标记设为地址的高**s**位
  6. 如果相同，缓存命中，从该行的**B**byte中取出1Byte

### 拓展

- 实际的缓存每组有多行，运行时会遍历每行比对标记，不命中时会选择一行覆盖
- 增加行数，缓存命中率提高，但花在其他操作上的时间会增加

### 提高缓存命中率

- 提高代码局部性，尽量连续访问内存，注意避免步长为2的正整数次幂的跳跃
- 单个函数的机器码是连续的（内联时除外），所以调用频繁的方法应尽量短（**指机器码行数**），尽量减少函数调用，如果要调用，尽量使两者的机器码靠近
- 使用内联时，要注意避免内联函数太长装不进缓存

## SIMD

单指令多数据流（Single Instruction Multiple Data），用一个指令处理多个数据（利用多个寄存器），能极大提高计算效率，一般用在**CPU**上。对于一些简单的向量运算，高级编译器会自动进行SIMD优化

## SIMT

单指令多线程（Single Instruction Multiple Thread），用多个线程同一个指令（同一个指令不是指一次指令，而是相同的一段机器码，处理器的多个核共享指令，而不共享数据），能极大提高计算效率，一般用在**GPU**上

# 动画

## Live2D

将人的图像分解为各个部件，每个部件具有自己的mesh、深度、几个控制点。控制点和深度按照输入移动，并计算mesh的变化

## Rigid Hierarchy Animation

- 最简单的骨骼动画，将物体分解为几个部分，由骨骼连接，每个部分可以作为一个整体在一定范围内运动，但每个部分内部无法变形

- 除了世界坐标系和模型坐标系，每根骨骼还有各自的本地坐标系，坐标系随骨骼旋转/位移而旋转/位移
- 每个顶点包含位移、朝向、缩放、骨骼默认长度（常量）数据，总自由度为9
- 骨骼默认长度指某顶点与下一个顶点间的距离，如果从一个顶点延伸出多个骨骼，这个顶点被视为位置重合的多个顶点（？）
- 人形骨骼根节点通常取角色两脚间，
- 朝向：**规定本地坐标系x轴的方向（x轴和两顶点连线未必重合）**
- 位移：本地坐标系下，此顶点指向下个顶点的位移
- 缩放：计算完位移后再进行缩放，影响顶点和皮肤上顶点的位置
- 位移、朝向、缩放都可以用4×4矩阵表示，将他们相乘得到**Affine Matrix**(计算顺序为朝向、位移、缩放)。**用任何一个顶点的模型坐标（扩展为4×4矩阵）左乘它的Affine Matrix，得到下一个顶点的模型坐标**。根节点的模型坐标不需要计算，额外存储（执行某些动作时，根节点坐标会变化）

## Per-vertex Animation

控制皮肤每个顶点的位置。过于复杂，通常由物理模拟产生

### Morph Target Animation

属于Per-vertex Animation，预设一些关键帧(每帧包含完整的顶点数据)，用一些可调节变量描述这些关键帧间的差异，最终呈现出的结果为这些关键帧各顶点位置的插值。常用于捏脸

## Skinned Animation

- 对Rigid Hierarchy Animation的完善，皮肤上每个点的位置不仅受自身所处骨骼的位置影响，**还受到附近的其他骨骼的位置的影响**。合理的函数关系能模拟出较为真实的皮肤质感。现代工具能让艺术家像绘画一样控制mesh随骨骼的运动这一过程背后的函数（通过类似于绘画的方式控制周围几个骨骼顶点的影响系数）


- 计算属于某块骨骼的mesh顶点的位置时，**在该骨骼的本地坐标系中**，获取周围相关顶点的坐标、缩放，根据函数计算出该顶点**在本地坐标系中的位置**，然后转换回世界坐标

### Root Joint

通常位于两脚之间，作为描述角色速度、位置的参照点。导出时，通常单独用位移曲线来表示

### Bind Point

用于控制两个物体的贴合，生效时，连接点处的位置和方向(局部坐标轴)都重合

### Interpolation

- 指两个关键帧内的动画通过插值得出

- position和scale通常用线性插值即可


- orientation使用NLerp/SLerp插值法


### Animation Compression

- 使用蒙皮动画时，每个关键帧要储存的数据为所有关节的位移、朝向、缩放


- 压缩的关键在于只保留几个关键帧，用某种方法拟合出曲线，关键帧是自动确定的，需要的关键帧数量的与动作的变化幅度有关
- 皮肤顶点位置的计算可以在CPU中计算，也可以在顶点着色器中（读取顶点默认位置和蒙皮矩阵，然后计算顶点实际位置）计算
- 只要骨架相同，物理和动画资源可以复用，不受蒙皮修改影响


### Blend

- 指多段动画混合成一段动画，两端动画间的插值，用于平滑过渡
- 混合要求动画具有某种相似性，比如走路与跑步混合时，脚落地的时间点要重合
- 用若干变量控制多个动画混合时的权重

# 粒子系统

## 要素

- 粒子：外观、运动方式、生命周期、环境交互
- 粒子发射器：发射速度、发射方向等

## 粒子类型

- Billboard Particle：始终朝向相机的二维图片
- Mesh Particle：许多粒子，每个粒子可以视为简化过的游戏物体，仅保留部分信息和部分交互（一个一个渲染的吗？）
- Ribbon Particle：一些粒子，粒子不是渲染的对象，而是渲染的位置依据（比如沿着粒子渲染出一条带）

## 粒子渲染

### 难点

- 数量多
- 透明物体多
- 粒子间相互混合

### 深度排序

- 逐粒子排序：开销大
- 逐Emitter排序：多个Emitter混合时效果不理想

# 声音系统

## 声音

- 响度：声波的振幅
- 音调：声波的频率
- 音色：主要指乐器的泛音（乐器不会只发出单个频率的声波，而是多个频率、响度不同的声波的混合）

$$
I = PV \quad P:声波的压强,V:音速,I:声强(单位面积内声波的功率) \\
L = k \log_{10}p \quad L:音量(分贝)
$$

![屏幕截图 2022-09-02 151203](屏幕截图 2022-09-02 151203.jpg)

## 三维声音渲染

# 工具链

**让编辑游戏更简便的工具，调用底层，以友好的界面和操作面向各类用户**

## 目标

### 版本兼容

- 核心问题是字段相较之前增加、减少了
- 按顺序读写字段不可行。需要为每个字段分配id（对于Json来说，变量名就是id）

### 可靠性

- 撤销/重复功能。将指令抽象成一个类，包括执行时行为、撤销时行为、标识符等

### 所见即所得

- 尽量能在编辑游戏时就能看到游戏运行时的效果
- 编辑器中便会执行部分游戏运行时的代码

### 可拓展性

- 主要的拓展方式是，继承/实现引擎的原有类/接口，然后主动调用或令引擎调用这些重写过的API

## GUI

### Immediate Mode

- 每帧直接调用绘图API来绘制
- 轻量级，可拓展性有限，效果有限

### Retained Mode

- 提交绘图指令，储存在缓冲区中，每帧GPU统一处理
- 效率高（能实现GUI热更新）

### MVC

- Model：除了自身的数据，只可能持有其他有影响的Model
- View：只持有自身的数据。根据自身数据调用绘图API，并提供输入事件API
- Controller：持有Model和View。一方面为输入事件绑定响应方法，修改Model数据；一方面将Model中的数据传给View

### MVVM

- Model：同MVC
- View：与MVC略有不同的是，通过某种方式（命名方式、标记等）将UI相关变量同Model中的变量**绑定**起来
- ViewModel：仅仅获取Model、通知View更新。以**绑定**为依据传递数据，而不用程序员写逻辑（原理类似特性和反射）

## 序列化

- 运行时数据转化为持久保存的数据
- 完全没有结构的数据必须按固定的顺序读写，无法应对数据丢失、更新。结构的存在允许了数据顺序交换、缺失、多余
- 不论有无结构，数据可以以某种方式“无损压缩”成二进制文件，乃至加密

## 反序列化

- 持久保存的数据转化为运行时数据
- 为了在大量数据中查询，通常使用树状结构（类似于字典的嵌套）

<img src="屏幕截图 2022-09-03 130851.jpg" alt="屏幕截图 2022-09-03 130851" style="zoom:50%;" />

## Varaiance

- 仅需要改变一个现有对象的**一部分**内容时会用到
- 一个游戏对象会引用各种素材，出于储存空间、修改成本等方面的考虑，应该不仅能直接引用，还能**继承**其他游戏对象的引用，继承者被称为被继承者的变体

## World Editor

World Editor工具既有按类型分的（粒子、动画……），也有按游戏内容分的（地形、道路……）

- Viewport：用于显示Editor模式下模拟出的游戏，执行相机移动、渲染、GUI、选中拖拽等逻辑（各种Editor逻辑和部分Runtime逻辑）
- Inspector
- Content Browser：核心是文件命名与检索功能，文件夹结构没有强制要求（比如资源类型→资源内容）
- Mouse Picking（Ray Casting）：鼠标与相机连线产生射线，进行射线检测（开销大，对复杂的mesh如果精确检测开销更大）
- RTT：渲染时，额外使用一个缓存记录物体id，鼠标选取时根据屏幕空间坐标在缓存中检索即可
- Transform Editing

- Instance Brush
- Rule System：特定游戏物体间的关系/约束，如：路必须贴合地面，路面上没有植被

## 反射

- 获取、利用类、实例、函数本身的信息（类型、字段、参数……）
- 主要利用编译过程中的数据，主要方式是字符匹配

# 事件系统

# 3C

# AI

## 寻路

### Waypoint Network

- 设置关键点，关键点间生成路径
- 寻路时，先回到最近的路径上（终点同样投影到最近的路径上），然后查找最短路径，适用Dijkstra算法
- 修改成本高，NPC行为受限

### Grid

- 地图划分为等大格子
- 适用A*算法。HCost小于等于无障碍距离时，必然能找到最短路径；HCost系数越大，找到路径越快
- 准确度有限，空间和时间开销大

### Navigation Mesh

- 地图划分为网格
- 寻路时，路径只能是**mesh的任意两条边的中点的连线**。到达一点后，将周围几条边的中点加入待选点，用和A*相同的方式在待选点中选择
- 找到路径后再平滑处理

### Sparse Voxel Octree

- 地图划分为八叉树（如果一个节点内存在不同类型的区域，就对其划分，直到完全属于同种区域或达到最小划分限度）
- 用于三维场景寻路，准确度有限，空间和时间开销大

## 路径与运动

### Seek&Flee

- 除了向固定点移动，物体还有跟随、逃离行为

### Velocity Match

- 物体加速度有限时，需要提前计算加速、减速时机

### Aligh

- 使物体转动到目标角度时，同样涉及角加速度

## 群体模拟

- Rule-based Model：对每个个体应用相同的规则
- Macrosopic Model：统一控制大量个体
- Mesoscopic Model：上述两种方法的结合

## 避障

- Force-based Model：依据某些数据，对物体施加额外的力，如：到墙壁的距离，到其他物体的距离
- Velocity-based Model：在Force-based Model的基础上，考虑其他物体的速度，如：B面向A移动比B静止对A产生的“斥力”更大

## 决策

### 行为树

- 节点有三种状态：Success，Failure，Running
- **每一帧都会获取根节点的返回值**。为了获取返回值，依次访问各种子节点，子节点的返回值一路向上返回到根节点；根节点一直处于Running状态，一旦返回Success，立刻重新进入根节点
- Sequence：按顺序执行节点。任何一个子节点Faliure，返回Faliure；一个子节点为Sucess且没有后续子节点时，返回Success
- Selector：选择一个（或多个）节点执行。所有子节点均为Faliure时，返回Faliure；Success的子节点数量达到设定值时，返回Sucess
- Paralell：所有子节点可以同时执行（能否进入子节点仅与节点自身逻辑有关，没有对子节点执行顺序和个数的限制）。所有子节点均为Faliure时，返回Faliure；至少一个子节点为Sucess且其他子节点为Faliure时，返回Sucess
- Decrator：多种功能型节点的统称，如：等待，循环
- Precondition：一个节点的Precondition不满足时，返回Faliure
- Blackboard：行为树涉及的环境变量。既有外部，也有内部；既有当前，也有历史
- 偏向于反应，而不是实现目标

### Hierachy Tasks Network

- 设定任务，然后将其逐级分解成更小的任务
- 介于反应和实现目标之间

#### 组成

- HTN Domain：有层级结构的任务，作为资源储存
- World State和Sensor：感知器与感知到的世界状态
- Planner：尚待执行的任务，运行时依据World State，从HTN Domain中取出任务
- Plan Runner：正在执行的任务，运行时依据任务的precondition和World State判断是否执行，执行完后根据effect更新World State

#### 任务

- 所有任务都有precondition、action、effect
- Primitive Task：原子任务，一旦执行，不会被打断，通常是一个非常简单的行为
- Combound Task：复合任务，包含多个**方法**。方法有优先级和条件。复合任务在方法中**选择一个执行**（或都不执行）。方法内部包含一串任务，**按顺序执行，直到完成所有任务或任何一个任务条件不满足**

#### 运行

*下列过程是简化版，没有利用Planner*

1. 从根任务开始
2. 执行复合任务
3. 逐个向下查找可执行的方法。如果没有可执行的方法，意味着这个复合任务被打断，获取此复合任务所属的方法，获取该方法所属的复合任务，在该复合任务中继续3（如果是根任务，回到1）
4. 访问方法中的下一个任务，如果是原子任务，跳转到5；如果是复合任务，跳转到2
5. 如果可执行此任务，执行并对World State应用effect，等任务执行完后回到4；如果不能执行，获取此原子任务所属的方法，获取该方法所属的复合任务，在该复合任务中继续3（如果是根任务，回到1）

<img src="屏幕截图 2022-10-02 103227.jpg" alt="屏幕截图 2022-10-02 103227" style="zoom: 25%;" /><img src="屏幕截图 2022-10-02 103652.jpg" alt="屏幕截图 2022-10-02 103652" style="zoom:25%;" />

### Goal Oriented Action Planning

- 偏向实现目标，而不是反应
- 不适用于非常复杂的游戏

#### 组成

- 同样有Planner，Plan Runner，Sensor，World State
- Goal Set：所有目标（非常明确的目标；不像HTN中，根任务只有一个，目标分散地体现在逐级任务中）
- Action Set：所有可采取的行动（不像HTN中，行为与任务绑定，而是可以灵活选择）

#### Gaol

- 同样有前置条件与优先级。**优先尝试完成优先级更高的目标，在此前提下尽量完成更多目标**
- 目标用World State（中的几项）表述（通常统一成bool变量）

#### Action

- 同样有前置条件和效果
- 有cost，作为可行Action的选择依据

<img src="屏幕截图 2022-10-04 082106.jpg" alt="屏幕截图 2022-10-04 082106" style="zoom:25%;" /><img src="屏幕截图 2022-10-04 082533.jpg" alt="屏幕截图 2022-10-04 082533" style="zoom:25%;" />

#### 运行

1. 按优先级顺序，获取下一个目标。如果之后没有任务，从头开始
2. 如果有可能能完成此目标，进行计划；否则，回到1
3. 在Action Set中找到能实现目标且cost最少的Action序列（**从目标开始往当前状态倒推**）。建立一个栈储存尚不满足的State，将当前World State与目标不一致的部分全部加入。逐个取出栈顶的State，找到可以满足此State的Action，将其加入Action序列中，如果该Action的前置条件对State有要求，将其入栈（实际上，需要规划各种可行路线，尽量规划出cost最小的序列。可以构建出一个图，在图上使用A*算法，可以使用与最终目标相差的State数估计距离）
4. 执行Plan。如果中途发现无法完成目标，回到1（从头开始？）

### Monte Carlo Tree Search

- 介于传统AI和机器学习之间
- 利用随机采样和统计的方法获得近似最优解
- 适用于输赢明确的游戏
- 构建树：游戏状态是节点，行为是边
- 每个节点有Q/N两个变量，分别为胜利次数和模拟次数
- 行为选择具有随机性，不过仍会遵循一些限制

#### 运行

1. 选择：从根节点开始，逐步往下选择，直到选中一个**可拓展的节点**。选择的依据是，始终选择所有子节点中UCB最大的节点（**每个子节点，总是优先选择有利于当前一方的策略，即，轮到黑棋/白棋下时，就站在黑棋/白棋的角度考虑；但是，每个节点的Q总是表示其中一方的胜利次数，所以奇数层和偶数层有各自的UCB表达式**）
2. 拓展：从选中节点的状态出发，选择下一步行动，并将新状态添加为选中节点的子节点
3. 模拟：从新增子节点开始向下模拟，直到给出游戏结果
4. 反向传播：向上更新结果，对于新增节点到根节点的所有节点，其N+1，如果这次模拟的结果是胜利；其Q+1，否则Q不变
5. 给出结果：在合适的时机停止模拟。然后从根节点的下一层子节点中选择一个，作为下一步行动。选择的依据是，选择子节点中LCB最大的节点

<img src="屏幕截图 2022-10-04 090829.jpg" alt="屏幕截图 2022-10-04 090829" style="zoom:50%;" />

#### Upper Confidence Bounds

$$
UCB = \begin{cases} 
\frac{Q}{N} + C \sqrt{\frac{2\ln N_p}{N}} \quad 此节点的层数为奇数 \\
\frac{N-Q}{N} + C \sqrt{\frac{2\ln N_p}{N}} \quad 此节点的层数为偶数 \\
\end{cases} \hfill \\
注:根节点为第0层,其子节点为第1层 \hfill \\
UCB:此数值越大,越优先探索此节点 \quad C:可调系数 \quad N_p:父节点的总探索次数  \hfill \\
$$

#### Lower Confidence Bounds

$$
LCB = \frac{Q}{N} -C\sqrt{\frac{2\ln N_p}{N}}  \hfill \\
LCB:此数值越大,越优先选择此节点 \quad C:可调系数 \quad N_p:父节点的总探索次数  \hfill \\
$$



# 网络

## OSI模型

<img src="image-20221231144212465.png" alt="image-20221231144212465" style="zoom:50%;" />

## 网络协议



## 网络同步

![屏幕截图 2022-09-04 095632](屏幕截图 2022-09-04 095632.jpg)

