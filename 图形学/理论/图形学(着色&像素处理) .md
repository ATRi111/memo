# 图像信号

## 二维傅里叶变换

<img src="屏幕截图 2022-11-03 093158.jpg" alt="屏幕截图 2022-11-03 093158"  />
$$
二维离散傅里叶变换: F(u,v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x,y) e^{-2j\pi(\frac{ux}{M} + \frac{vy}{N})}\hfill \\
逆变换:f(x,y) = \frac{1}{MN} \sum_{u=0}^{M-1} \sum_{v=0}^{N-1} F(u,v) e^{2j\pi(\frac{ux}{M} +\frac{vy}{N})}\hfill \\

F(u,v):变换结果(复变函数) \quad R(u,v):实部 \quad I(u,v):虚部的实系数 \hfill \\
\\
对于变换结果的任意一点(u_0,v_0): \hfill \\
A=|F|=\sqrt{R^2+I^2} \quad w = \sqrt{u^2+v^2} \quad \mathbf v = (u,v) \quad \phi = \arctan[\frac{I}{R}] \hfill \\
A:振幅 \quad w:频率 \quad \mathbf v:方向 \quad \phi:相位 \hfill \\
$$

- 图像可以分解为无数二维正弦波的叠加，二维正弦波除了具有频率、幅度、相位，还具有方向

<img src="image-20240803132954610.png" alt="image-20240803132954610" style="zoom:50%;" />

*右上图像为左上图像的振幅谱*

- 图像的**谱**：包括**振幅/相位谱**，均为灰度图，以u/v为横纵坐标，图像中心点为原点，各点的**灰度**为该点对应波的**振幅/相位**
  - 谱中，一点到中心点的距离表示信号频率，一点相对于中心点的方向表示信号的方向
- 处理时可能会将原图复制若干份拼接起来，再计算中间一份的信号（本质上是延拓图像信号的定义域）
  - 原图如果不是自拼接的，那么连接处一定会存在高频信号（因此傅里叶变换的结果图中出明亮的水平和竖直线）

## 采样

<img src="image-20240803132741215.png" alt="image-20240803132741215" style="zoom:50%;" />

- 采样定理：对模拟信号（连续信号）采样时，采样频率至少要到达模拟信号最高频率的两倍，才能还原出原始信号
- 渲染过程中，“模拟信号”对应纹理（纹理仍然是离散的），“离散信号”对应渲染得到的图像
- **走样来源于采样频率（时间频率/空间频率）不足**
- 走样可能导致**锯齿、摩尔纹、视错觉**等现象

![image-20240803111317691](image-20240803111317691.png)

- 采样频率不足时，在采样前使用**低通滤波**能够缓解走样（最常见的是均值滤波）

## 反走样


- 默认片元采样方式：对于每个片元，使用一个**采样点**，直接取**当时**的采样结果为输出结果

### 超采样(Super Sampling)

- 每个片元使用**多个采样点**，分别计算采样结果，对其**加权平均**得到输出结果
- 采样的开销成倍增加

### 多重采样(Multiple Sampling)

- 如果一个片元靠近所属图元**边缘**，则使用多个采样点，仅在一个（图元内部的）采样点进行着色计算，其他采样点只进行**覆盖计算**，**输出结果=颜色计算结果×覆盖比例**；如果一个片元远离所属三角形边缘，仍使用一个采样点

- 效果与超采样相近，而开销显著降低

### 时间采样(Temporal Sampling)

<img src="image-20240803143256736.png" alt="image-20240803143256736" style="zoom:50%;" />

- 用于片元着色器中反走样
- 每个片元使用**当前采样点**，以及**前若干帧内“相同位置”的片元的采样结果**，对其**加权平均**得到输出结果
  - 采样点（相对于片元中心）的位置不必固定，可以随时间按一定规律变动
  - 每个片元中心会映射到某物体的某个纹理上的某个位置，（近似）映射到**同一物体的同一纹理的同一纹理坐标**的两个片元中心，称其为“相同位置”的片元
  - **重投影**：使用**速度缓冲**，来确定上一帧的某个片元与当前帧的哪个片元“位置相同”，
  - **数据验证**：使用某种规则来对前后采样结果对比检查，确定是否可能发生物体抖动、遮挡关系变化、光照变化等特殊情况，视情况考虑是否放弃前若干帧的采样结果
- 不增加总采样次数，开销较低

## 滤波

### 空间域滤波

$$
一元函数卷积:g(t) = h * f = \int_{-\infin}^{\infin}h(t-\tau)f(\tau)\mathrm d \tau \hfill \\
二元函数卷积:g(x,y) = h * f = \int_{-\infin}^{\infin} \int_{-\infin}^{\infin} h(x-u,y-v)f(u,v) \mathrm d u \mathrm d v \hfill \\
$$

- 将图像视为二元函数，空间域滤波的本质是卷积运算。而图像是离散的，所以卷积运算的具体方法是在图像上**应用"模板"**
- **对图像应用空间域滤波，然后每次采样单点，等价于不滤波，然后每次采样多点加权平均**
  - **由于overdraw现象的存在，前一种做法的效率明显高于后一种**
  - **两种做法仍然可以一起使用**

- 均值滤波：以默认方式应用一个模板；效果为，某像素的颜色变为周围像素颜色的加权平均
- 中值滤波：应用一个模板，模板的作用仅仅是规定一个区域；某像素的颜色变为自身及周围若干个像素的颜色的“中位数”
- 微分锐化
  - Roberts锐化算法：对原图像应用两个模板，两个结果的和为结果
  - Priwittl锐化算法：对原图像应用两个模板，两个结果的平方和为结果
  - Sobe锐化算法：过程同Priwittl锐化算法

![image-20221103151442847](image-20221103151442847.png)

### 频率域滤波

- 将图像视为二元函数，频率域滤波的过程是固定的：
  1. 预处理
  2. 对图像进行离散二维傅里叶变换（空间域→频率域）
  3. 对变换结果进行某种处理
  4. 对图像进行离散二维逆傅里叶变换（频率域→空间域）
  5. 后处理

### 高通滤波

<img src="image-20240803135003688.png" alt="image-20240803135003688" style="zoom:50%;" />

- 去除低频信号；效果大体为保留边缘，去除色块

### 低通滤波

<img src="image-20240803135626769.png" alt="image-20240803135626769" style="zoom:50%;" />

- 低通滤波：去除高频信号；效果大体为图像变得模糊
- **低通滤波+单点采样≈不滤波+多点采样取平均**

# 着色

- **计算各片元的颜色**，待之后测试混合得到像素颜色，通常涉及以下值：
  - **原始颜色**：由**纹理映射**确定计算方式
  - **直接光照亮度**：由**光照模型**确定计算方式（计算直接光照亮度时不考虑遮蔽）
  - **遮蔽值**：计算**阴影**的本质是计算遮蔽值（直接光照亮度和遮蔽值分别独立地计算）
  - **间接光照亮度**：**全局光照**中包含若干种计算间接光照的方法
- **计算用到的纹理坐标、法线等数据通常在几何阶段便计算完毕**

## 着色方式

- **Flat Shading：**每个面着色一次（法线方向为任意两边的叉积），该面的所有片元颜色相同

- **Gouraud Shading：**每个顶点着色一次，每个片元的颜色根据所属三角形顶点的颜色，利用重心坐标插值而得（直接对颜色插值完全不符合光学规律）

- **Phong Shading：**每个片元着色一次

## 法线计算

<img src="image-20240805090431355.png" alt="image-20240805090431355" style="zoom:50%;" />

- **面法线**：该面任意两边的叉积
- **顶点法线**：通常由包含该顶点的所有面的法线方向平均而得（简单平均，或根据各个面的面积加权平均）
  - 顶点法线方向是建模时就确定好的，如果自动计算的结果不合适，可以人为修改顶点法线

- **片元法线**：根据所属面各顶点的法线，利用重心坐标插值而得
  - 理论上，一个面内的所有片元应当具有相同的法线方向；但现实中的物体由无数多的三角形面构成，模型无法精确模拟
  - 多数情况下，改用插值计算片元法线，能够使各个面过渡更平滑，看起来反而更真实，因此这是默认的计算方式
  - 如果确实要表现边缘锐利的平面，可以人为增加一些位置相同，法线不同的顶点，使每个面各顶点法线相同

### 法线贴图(Normal Map)

- 直接规定每个**纹素**的法线方向（法线是三维方向向量，可以用**RGB图**记录）
- 法线贴图是**切线空间**下的数据（**默认表面朝向Z轴正方向**），实际使用时要变换到**观察空间**
- 每个片元不再通过顶点插值计算法线方向，而是通过纹理映射计算
- 仅改变法线方向只能呈现出部分凹凸效果


### 位移贴图(Displacement Map)

- 直接规定每个**纹素**相对于所属模型平面的凹凸量（规定凹下或凸起的方向总是垂直于平面，所以可以用**灰度图**记录）
- 位移贴图在几何阶段就会发挥作用，会改变若干顶点的位置，乃至增加新的顶点和三角面（利用**动态曲面细分**技术）
- 每个片元不再通过顶点插值计算法线方向，而是映射到位移贴图，根据该点附近纹素的凹凸量直接计算出法线
- 位移贴图不仅改变法线方向，影响直接光照计算；还改变几何数据，影响阴影计算等（不影响渲染以外的系统）

## 纹理映射

- 纹理不仅包括颜色贴图，还包括法线贴图、粗糙度贴图、环境光贴图等

- 纹理空间：纹理左下角为原点，纹理右上角为(1,1)（如果纹理坐标超出此范围，则需要考虑纹理的延展方式）
  - 若纹理分辨率为N×N，则纹素在纹理空间内是边长为1/N的正方形
  - 片元在屏幕空间内是边长为1的正方形，映射到纹理空间后为形状和大小不确定的四边形

- 理想情况下，进行纹理映射时，**计算其在纹理空间中对应的区域，结果为该区域中所有纹素的平均值**

![image-20250131110701432](image-20250131110701432.png)

- **顶点纹理坐标**：为模型设定纹理时，每个顶点的纹理坐标便已确定，存放在顶点缓冲区中
  - 为了确保映射正确，

- **片元纹理坐标**：根据所属面各顶点的纹理坐标，利用重心坐标插值而得

<img src="image-20240805100712003.png" alt="image-20240805100712003" style="zoom:50%;" />

- **最近点(Nearest)**：取最接近片远纹理坐标的单个纹素，直接取其纹理值

- **双线性插值(Bilinear)**：取最接近片元纹理坐标的四个纹素，求其纹理值的双线性插值

### Mipmap

<img src="image-20240805100806509.png" alt="image-20240805100806509" style="zoom:50%;" />

- **Mipmap**：基于原纹理额外生成的若干个纹理；每次将前一次的纹理长和宽压缩为1/2
  - 原纹理每四个纹素（2×2）一组，其平均值存放在一个纹理中，以此方式压缩
  - 占用的总显存为原纹理的133%

<img src="image-20240805101108249.png" alt="image-20240805101108249" style="zoom:50%;" />

*上左图中，每个纹素的尺寸为1/16，上右图中，每个纹素的尺寸为1/8；尺寸介于这两个值之间片元会被映射到这两个mipmap上*

- **三线性插值(Trilinear)**：求出纹理空间内某片元的尺寸，映射到**尺寸最接近的两张mipmap上**，两张mipmap中分求双线性插值，其结果再求线性插值

<img src="image-20240805102351404.png" alt="image-20240805102351404" style="zoom:50%;" />

- **片元尺寸**：一个片元与其相邻片元的纹理坐标的差值可以近似表示该片元在纹理空间内的尺寸

### 各项异性过滤

<img src="image-20240805102906528.png" alt="image-20240805102906528" style="zoom:50%;" />

- **Ripmap**：基于原纹理额外生成的若干个纹理；每次将前一次的纹理长或宽压缩为1/2
  - 原纹理每两个纹素（1×2或2×1）一组，其平均值存放在一个纹理中，以此方式压缩
  - 可以设置**各项异性倍率**，如16×表示长和宽最多压缩到1/16
  - 各向异性倍率为2×时，占用总显存为原纹理的225%；为无穷大时，则占用的总显存近似为400%

- **各向异性过滤(Anisotropic Filtering):**求出纹理空间内某片元的长宽，映射到**长宽最接近的四张ripmap上**，四张ripmap中分求双线性插值，其结果再求双线性插值

## 渲染方程

$$
L(\mathbf p,\mathbf v) = L_e(\mathbf p,\mathbf v) +L_r(\mathbf p,\mathbf v) \hfill \\
L_r(\mathbf p,\mathbf v)= \int_{\Omega^{+}} L(\xi,-\mathbf l) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
注意到\mathbf l \cdot \mathbf n=\cos\langle \mathbf l,\mathbf n \rangle \quad (兰伯特余弦定理) \quad \mathbf n由\mathbf p决定,故自变量不列出\mathbf n \hfill \\
\\
\mathbf p:被观察点位置 \quad \mathbf v:由\mathbf p指向观察者位置的单位向量 \quad
\mathbf l:由\mathbf p指向光源(或反射源)的单位向量 \hfill \\
\mathbf n:\mathbf p处的单位法向量 \quad \Omega:以\mathbf p为中心,以\mathbf n为朝向的半球面(理论上总有\mathbf l \cdot \mathbf n \ge 0) \hfill \\
\\
L(\mathbf p,\mathbf v):从\mathbf p沿\mathbf v方向发出和反射光线的总亮度 \hfill \\
L_e(\mathbf p,\mathbf v):从\mathbf p沿\mathbf v方向的自发光亮度 \hfill \\
L(\xi,-\mathbf l) :所有沿-\mathbf l射到\mathbf p的光线的总亮度\hfill \\
L_r(\mathbf p,\mathbf v) :从\mathbf p沿\mathbf v方向的反射光亮度 \hfill \\
\\
直接求解:L_r(\mathbf p,\mathbf v) 
=\int_{\Omega^{+}} L_i(\mathbf p,\mathbf v) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
=\int_0^{2\pi} \mathrm d \theta \int_0^\frac{\pi}{2} L_i(\mathbf p,\mathbf v) (\mathbf l \cdot \mathbf n)f(\mathbf p,\mathbf l,\mathbf v)\sin \phi \mathrm d\phi \hfill \\
其中,\mathbf l=\{\cos \theta\sin \phi,\sin \theta \sin \phi,\cos \phi\} \hfill \\
\\
对于单一光源直射某点的情况,L_r(\mathbf p,\mathbf v)= E(\mathbf o,\mathbf p) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \hfill \\
E(\mathbf o,\mathbf p):光源\mathbf o在\mathbf p产生的光照度;如理想点光源直射时,E(\mathbf o,\mathbf p)=\frac{\Phi}{4\pi(\mathbf o-\mathbf p)^2} \hfill \\
\\
对于只考虑漫反射的情况,L_r(\mathbf p,\mathbf v)= \int_{\Omega^{+}} L(\xi,-\mathbf l) (\mathbf l \cdot \mathbf n) k_d(\mathbf p) \mathrm d\omega=k_d(\mathbf p)E(\mathbf p) \hfill \\
E(\mathbf p):所有光源,反射源在\mathbf p产生的光照度(已考虑照射角) \hfill \\
此情况下k_d(\mathbf p)=\frac{\rho(\mathbf p)}{\pi} \quad \rho(\mathbf p):\mathbf p点处的反射率 \hfill \\
恒有0 \le \rho(\mathbf p) \le 1 \quad \rho(\mathbf p) = 1时,入射光被完全反射,总能量不变 \hfill \\ 
注意:\int_{\Omega^{+}} \mathrm d\omega=2\pi,\int_{\Omega^{+}} (\mathbf l \cdot \mathbf n) \mathrm d\omega=\pi \quad (\mathbf l \cdot \mathbf n) \mathrm d\omega表示立体角投影,其总和即表示半球面投影而得的圆的面积\hfill \\
$$

- 渲染方程是**二重积分**
- **渲染方程不涉及颜色，要将其用于着色，需考虑可见光范围内的SPD；而SPD过于复杂，将其转换为线性颜色空间中的坐标，然后亮度运算变为线性颜色空间内的颜色值运算**
- 在仅考虑反射的光照模型中，$f(\mathbf p,\mathbf l,\mathbf v)$即双向**反射分布函数(BRDF)**；如果还考虑透射，那么此函数中额外包含**双向透射分布函数(BTDF)**，二者合称**双向散射(BSDF)分布函数**
  - **此函数的量纲是$\frac{1}{\omega}$，单位为$\mathrm{sr}^{-1}$，与光照度相乘得到亮度**

### Split Integral

$$
\int_a^b f(x)g(x) \mathrm dx \approx \frac{\int_a^b f(x) \mathrm dx}{\mathrm dx}\int_a^b g(x) \mathrm dx \hfill \\
f(x)或g(x)任意一个在[a,b]内的取值变化较小时,此近似较为准确;此式可推广到曲线/曲面积分 \hfill \\
$$

- 积分计算成本过高可以通过预计算解决，但如果积分中的变量过多，需要用高维数据结构存储，其空间成本无法接受
- 环境映射和全局光照都需要处理来自所有方向的光照，其中的许多方法都体现了Split Integral的思想

## 光照模型

### Blinn-Phong模型

- 认为**反射光=环境光(Ambient)+漫反射(Diffuse Reflection)光+镜面反射光(Specular Reflection)**
- 规定了漫反射和镜面反射的计算方式（只考虑直接光照）

<img src="屏幕截图 2022-05-24 104437.jpg" alt="屏幕截图 2022-05-24 104437" style="zoom:50%;" />
$$
给定物体表面一点\mathbf p,考虑单一光源,规定f(\mathbf l,\mathbf v,\mathbf n) = k_d + k_s\frac{(\mathbf n \cdot \mathbf h)^p}{(\mathbf l \cdot \mathbf n)}: \hfill \\
\underset{direct}{L_{r}(\mathbf p,\mathbf v)}= E [k_d(\mathbf p)(\mathbf l \cdot \mathbf n) + k_s(\mathbf p)(\mathbf n \cdot \mathbf h)^g] \quad 其中\mathbf h =\frac{ \mathbf l + \mathbf v}{|\mathbf l+\mathbf v|} \hfill \\
\underset{direct}{L_{r}(\mathbf p,\mathbf v)}:直接光照产生的反射光亮度 \quad E:光源\textbf{直射} \mathbf p处产生的光照度\hfill \\
k_d(\mathbf p):\mathbf p处的漫反射系数 \quad k_s(\mathbf p):\mathbf p处的镜面反射系数 \quad g:可调参数,g越大高光越集中 \hfill \\
注意:k_d(\mathbf p)和k_s(\mathbf p)的量纲是\frac{1}{\omega},与光照度相乘后,得到亮度 \hfill \\
$$

- **实际用于着色时，对RGB三个分量的反射率不同（由贴图规定），自然体现出物体的颜色**
- 越光滑的物体，其镜面反射越强，即反射光越集中于与入射光对称的方向上（因此高光区域随光源和观察点变化而变化）
- 难以表现出各种不同的材质，塑料感强

### Trowbridge-Reitz(GGX)模型

<img src="image-20250812163410422.png" alt="image-20250812163410422" style="zoom:50%;" />

*上图中，从球体中心移动到边缘的过程中观察角不断增大，镜面反射越来越明显，到极大值点后迅速衰减*

- 由Microfacet模型推导出
- 物体的表面从微观的角度看，是凹凸不平的；物体表面的法线越趋近于同一个方向，看起来越光滑；法线越分散，看起来越粗糙

$$
给定物体表面一点\mathbf p,考虑单一光源,规定f(\mathbf l,\mathbf v,\mathbf n) = k_d + \frac{D(\mathbf n,\mathbf l)F(\mathbf n,\mathbf l)G(\mathbf v,\mathbf n,\mathbf l)}{4 \ (\mathbf l \cdot \mathbf n)(\mathbf v \cdot \mathbf n)}: \hfill \\

\underset{direct}{L_{r}(\mathbf p,\mathbf v)}= E (\mathbf l \cdot \mathbf n) \left[k_d(\mathbf p) + \frac{D(\mathbf n,\mathbf l)F(\mathbf n,\mathbf l)G(\mathbf v,\mathbf n,\mathbf l)}{4 \ (\mathbf l \cdot \mathbf n)(\mathbf v \cdot \mathbf n)} \right] \hfill \\
D(\mathbf n,\mathbf l) = \frac{\alpha^2}{\pi((\mathbf n \cdot \mathbf h)^2(\alpha^2-1)+1)^2} \quad 其中\mathbf h =\frac{ \mathbf l + \mathbf v}{|\mathbf l+\mathbf v|} \hfill \\
F(\mathbf n,\mathbf l) = \mathrm{Lerp}\{F_0(\mathbf p),1,(1 - \mathbf v \cdot \mathbf h)^5\}=F_0(\mathbf p) + (1-F_0(\mathbf p))(1 - \mathbf v \cdot \mathbf h)^5 \hfill \\
G(\mathbf v,\mathbf n,\mathbf l) = g(\mathbf l)g(\mathbf v) \quad 其中 g(\mathbf x) = \frac{\mathbf n \cdot \mathbf x}{(1-k)\mathbf n \cdot \mathbf x + k} \quad k = \frac{(\alpha + 1)^2}{8} \hfill \\
\\
D:描述法线的分散程度 \quad F:描述菲涅尔现象的强度 \quad G:描述表面凹凸带来的吸光能力(值越大,吸光能力越弱) \quad \hfill \\
\alpha:\mathbf p处的粗糙度,[0,1] \quad F_0(\mathbf p):\mathbf p处的菲涅尔反射率 \hfill \\
$$

- **对于一个给定片元，其几何参数均确定，则镜面反射光强度取决于多个参数，漫反射光仅取决于漫反射系数**
  - 菲涅尔反射率决定菲涅尔现象的强度；金属较高，非金属较低，介于两者之间的值看起来不真实(如半导体)
  - 法线越分散，镜面反射越弱，因此D越小
  - 观察角越大，菲涅尔现越明显，因此F越大
  - 观察角越大，被凹凸不平的微观结构遮挡的光线就越多，因此G越小

- 能比较真实地表现各种材质

| 材质类型 | 描述                 | 举例         | 计算全局光照时合适的采样方向         |
| -------- | -------------------- | ------------ | ------------------------------------ |
| Diffuse  | 以漫反射为主         | 非金属面     | 分散在各个方向上                     |
| Glossy   | 兼有镜面反射和漫反射 | 粗糙的金属面 | 大部分集中在观察方向镜面对称的方向上 |
| Specular | 以镜面反射为主       | 光滑的金属面 | 集中在观察方向镜面对称的方向上       |

#### PBR材质

- 基于Trowbridge-Reitz(GGX)模型设计的材质，关键在于以下贴图：


  - Diffuse图：RGB，粗略模拟对不同波长的光的吸收率，与漫反射光强度相乘


  - Specular图：RGB，粗略模拟对不同波长的光的吸收率，与镜面反射光强度相乘


  - Glossiness图：灰度，表示**光滑度（=1-粗糙度）**，影响镜面反射光亮度


#### Metallic PBR材质

- PBR材质的图难以理解，不利于创作者制作，Metallic PBR材质对PBR材质进行了简化和包装：


  - Albedo图：RGB，同时影响镜面反射光和漫反射光颜色


  - Roughness图：灰度，表示粗糙度，影响镜面反射光亮度


  - Metallic图：灰度，表示金属度，影响镜面反射光亮度

## 直接光照

$$
L_r(\mathbf p,\mathbf v)= \underset{direct}{L_{r}(\mathbf p,\mathbf v)}+\underset{indirect}{L_{r}(\mathbf p,\mathbf v)} \quad 
\underset{direct}{L_{r}(\mathbf p,\mathbf v)}= \sum_i E(\mathbf o_i,\mathbf p)V\mathbf(\mathbf o_i,\mathbf p) (\mathbf l_i \cdot \mathbf n) f(\mathbf p,\mathbf l_i,\mathbf v) \hfill \\
其中\mathbf l_i= \mathbf o_i-\mathbf p  \hfill \\
\underset{direct}{L_{r}(\mathbf p,\mathbf v)}:直接光照产生的反射光亮度 \quad \underset{indirect}{L_{r}(\mathbf p,\mathbf v)}:间接光照产生的反射光亮度 \hfill \\
E(\mathbf o_i,\mathbf p):光源\mathbf o_i\textbf{直射}\mathbf p产生的光照度 \quad V\mathbf(\mathbf o_i,\mathbf p):\mathbf o_i与\mathbf p间的可见度,[0,1],0表示直射光完全被遮挡 \hfill \\
$$

### Shadow Mapping

$$
\underset{direct}{L_{r}(\mathbf p,\mathbf v)}= \sum_i L_{e}(\mathbf o_i,-\mathbf l_i)V\mathbf(\mathbf o_i,\mathbf p) (\mathbf l_i \cdot \mathbf n) f(\mathbf p,\mathbf l_i,\mathbf v) \hfill \\
\approx \overline{V_i}\sum_i L_{e}(\mathbf o_i,-\mathbf l_i)(\mathbf l_i \cdot \mathbf n) f(\mathbf p,\mathbf l_i,\mathbf v) \hfill \\
其中\mathbf l_i= \mathbf o_i-\mathbf p  \hfill \\
$$

- 理论上，每个光源的光照颜色应当分别与其可见度相乘，再相加；而实际中，经常用所有光源的平均可见度与各光源颜色相乘得到近似的结果
- 物体的材质以漫反射为主时，上式近似较为准确（漫反射为主便意味着各方向上$ f(\mathbf p,\mathbf l,\mathbf v)$变化不大）

<img src="屏幕截图 2022-08-28 104740.jpg" alt="屏幕截图 2022-08-28 104740" style="zoom:50%;" />

*对于上图，P1无阴影，P2有阴影但是被剔除，P3有阴影*

- 总体过程：
  1. **对于每个产生阴影的光源，额外使用一个Pass（通常称为Light Pass），每个Pass的渲染结果为一个ShadowMap**
  2. **对于每个片元，向片元着色器输入各个ShadowMap及对应的光源矩阵**
  3. **根据光源矩阵，计算片元到光源的深度，以及在ShadowMap中的纹理坐标**
  4. **通过纹理坐标对ShadowMap采样，获取对应像素记录的深度，根据深度判断遮挡关系**

- 渲染Shadow Map相当于**以光源为相机（此情况下的观察空间称为光源空间）**，使用特殊的着色器，渲染出深度缓冲
  - Shadow Map在运行时动态更新，每帧更新若干次
  - 屏幕空间和Shadow Map分辨率不同、方位不同，导致屏幕空间的片元和Shadow Map中的“像素”并不一一对应
  - 特别的，渲染平行光源使用正交相机
  - 光源空间的Z轴正方向就是光源朝向，XY轴可以在XY平面内旋转（合适的XY轴朝向可以使得Shadow Map分辨率更小）
  - 确定光源坐标系后，便可确定**世界空间坐标→光源空间坐标的基变换矩阵**，用在**渲染Shadow Map的顶点着色器**中
  - 还需要将**世界空间坐标和基变换矩**阵传给**渲染到窗口的片元着色器**
- 将某个片元到光源的深度记为**A**，ShadowMap中对应的像素记录的深度记为**B**：
  - A=B：表示光源可直射该片元
  - A>B：表示该片元与光源之间有物体遮挡
  - A<B：理论上不会发生
- 然而实际上计算A，B时必然产生误差：
  - A=B：完全相等的可能性几乎为0
  - A>B：理论上A=B的位置，有可能因误差进入这种情况，进而导致错误地认为该位置被遮蔽
  - A<B：理论上A=B的位置，有可能因误差进入这种情况，因此也认为光源可直射该片元
- 为避免错误，计算出A后，将其适当地减小一个值，该值被称为**阴影偏移(Shadow Bias)**
  - 设置阴影偏移会导致一些“原本存在”的阴影“消失”，尤其是细小凹凸处
- 由于精度有限，Shadow Map仅适用于以漫反射为主的材质（因为亮度变化平滑）
- Shadow Mapping计算出的可见值非0即1，即只有可见和不可见之分，因此称为**硬阴影**（符合理想点光源、理想平行光源）
- **光源数量的增加**和**照射范围的扩大**会显著增加ShadowMapping的时间成本

#### Second-Depth Shadow Mapping

![image-20250202120942909](image-20250202120942909.png)

*光源从上往下照射；Shadow Mapping的效果相当于左图，Second-Depth Shadow Mapping的效果相当于右图*

- 对Shdow Mapping的一种改进，最终的ShadowMap中，记录的不是最近片元的深度，而是**最近和次近片元深度的中间值**
- 不必再使用Shadow Bias
- 要求所有物体都具有水密性（有体积的封闭曲面），这一点难以实现（如游戏引擎中可以使用无厚度单向平面）

#### Percentage Closer Filtering

- PCF是对**可见度**滤波（如果对深度滤波，最终计算出的可见度还是非0即1）
  - 可见度是片元着色器计算过程中的临时变量，因此要修改片元着色器，令其每次采样Shadow Map的一个区域
  - 通常采用均值滤波，即可见度=**区域中比片元深度更大的像素占区域总像素数的百分比**
- 目的是消除硬阴影中的锯齿

#### Percentage Closer Soft Shadow

<img src="image-20250202152115344.png" alt="image-20250202152115344" style="zoom: 33%;" /><img src="image-20250202153614324.png" alt="image-20250202153614324" style="zoom: 33%;" />

*如左上图，现实中的光源有一定体积，下方棕色区域即半影区域*
$$
w_p=\frac{d_r-d_b}{d_b}w_l \hfill \\
w_p:半影尺寸 \quad w_l:光源尺寸(常数) \quad d_r:投影平面到光源的距离 \quad d_b:遮挡物到光源的距离 \hfill \\
计算阴影过程中,\frac{d_r-d_b}{d_b}w_l=k\frac{片元深度-遮挡物平均深度}{遮挡物平均深度} \hfill \\
$$

- 对PCF的一种改进，不是对每个片元使用统一的滤波方式，而是**半影越大，卷积核越大**（因为这样更符合真实）
- 总体过程：
  1. 对于每个产生阴影的光源，额外使用一个Pass（通常称为Light Pass），每个Pass的渲染结果为一个ShadowMap
  2. 对于每个片元，向片元着色器输入各个ShadowMap及对应的光源矩阵
  3. 根据光源矩阵，计算片元到光源的深度，以及在ShadowMap中的纹理坐标
  4. **在一定范围内采样Shadow Map，计算遮挡物平均深度**
     - **采样范围可以固定（如5×5），也可以考虑光源尺寸、到光源的距离等（见右上图）**
     - **在采样范围内，只有深度比片元小的像素才是遮挡物，所以只有这些像素参与遮挡物平均深度计算**
  5. **根据遮挡物平均深度、片元深度，估计半影大小，进而确定第二次采样范围**
  6. **第二次采样Shadow Map，深度更大的片元占总片元数的百分比即可见度**
- PCSS得到的这种可见度平滑变化的阴影，称为**软阴影**（符合体积相对于距离不可忽略的光源）

#### Variance Soft Shadow Mapping

<img src="image-20250203102224679.png" alt="image-20250203102224679" style="zoom:50%;" />

*上图表示一个区域内所有像素的深度的分布*
$$
V(\mathbf x)=1-F_X(x) \quad X \overset{近似}{\sim} N(\mu,\sigma) \hfill \\
\mu \approx \overline{X} \hfill \\
\sigma^2 =EX^2-(EX)^2 \approx \overline{X^2}-{\overline X}^2 \hfill \\
V(\mathbf x): \mathbf x处的片元的可见度 \quad x:\mathbf x处片元到光源的深度 \quad X:\mathrm{Shadow Map}采样区域内某像素的深度 \hfill \\
\overline{X}:\mathbf x区域内像素深度的样本均值 \quad \overline{X^2}:区域内像素深度平方的样本均值 \hfill \\
\\
N \overline{X}=\underset{X\ge x}{N} \underset{X\ge x}{\overline{X}}+\underset{X<x}{N} \underset{X<x}{\overline{X}} \hfill \\
\Rightarrow \underset{X<x}{\overline{X}}
=\frac{ N\overline{X}- \underset{X\ge x}{N} \underset{X\ge x}{\overline{X}}}{\underset{X<x}{N}} \hfill \\
\approx \frac{\overline{X}-(1-F_X(x))\underset{X\ge x}{\overline{X}}}{F_X(x)} \quad (通过分布,估计深度大于/小于x的像素的比例)\hfill \\
\approx \frac{\overline{X}-(1-F_X(x))x}{F_X(x)} \quad (直接将深度大于x的像素的深度统一视为x) \hfill \\
N:区域内像素总数 \quad \underset{X < x}{N}:区域内深度小于x的像素总数 \quad \underset{X < x}{\overline{X}}:区域内深度小于x的像素的平均深度 \hfill \\
$$

- 认为Shadow Map**任意区域中的深度总是符合正态分布**，求“深度更大像素百分比”便转化为求正态分布概率分布函数取值
- 总体过程：
  1. 对于每个产生阴影的光源，额外使用一个Pass（通常称为Light Pass），每个Pass的渲染结果为一个ShadowMap
  2. 预计算生成两个SAT，分别记录某个区域内深度的二维前缀和，以及深度的平方的二维前缀和
  3. 对于每个片元，向片元着色器输入各个ShadowMap及对应的光源矩阵
  4. 根据光源矩阵，计算片元到光源的深度，以及在ShadowMap中的纹理坐标
  5. **在一定范围内采样Shadow Map，利用SAT和近似方法快速计算遮挡物的平均深度**
  6. 根据遮挡物平均深度、片元深度，估计半影大小，进而确定第二次采样范围
  7. **第二次采样Shadow Map，利用SAT快速确定该范围内深度所符合正态分布的参数，再通过概率分布函数计算可见度**
- 查询SAT取代采样操作，大幅加快可见度计算，但精确度不如PCSS
  - 由于实际的深度分布不一定符合正态分布，计算得到的可见度时大时小
  - 可见度偏小相对可接受，可见度偏大则会导致明显的**漏光(Light Leaking)**问题

#### Distance Field Soft Shadow



#### 级联阴影(Cascade Shadow)

- 将视锥由近到远分为几个区域，对于不同阶段内的**物体**，深度写入到Shadow Map时采用的精度不同
- 两个阶段间需要实现平滑过渡

#### Vitual Shadow Map

<img src="image-20240821103605683.png" alt="image-20240821103605683" style="zoom:80%;" />

- 类似虚拟内存，随着可见区域变化，**动态加载和释放Shadow Map**，以节约显存空间

## 环境映射(Environment Mapping)

![image-20250204135959044](image-20250204135959044.png)

*根据映射方式的不同，球面可以展平成不同形状*

![image-20250623145439837](image-20250623145439837.png)
$$
环境映射:\underset{env}{L_r(\mathbf p,\mathbf v)}= \int_{\Omega^{+}} L_r(\mathbf o_e,-\mathbf l)V(\mathbf p,\mathbf l) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
\mathbf o_e:\textbf{充分远处}的环境光源 \hfill \\
$$

- **环境光表示场景中“静态”的光源和反射源，用环境贴图记录来自场景外围各个方向的入射光颜色**

  - **对于会运动的光源和物体，其光照计算与环境映射通常是独立的**

  - **环境贴图被视为包围整个场景，且距离各物体充分远的光源（所以着色时可忽略片元相对于物体中心的偏移）**
  - **理论上，记录的是来自球面各方向的入射光；而实际存储时，总是要展开成平面图像（常见的是展开成立方体的六个面）**
  - **实际渲染时，将环境贴图视为一种特殊球面光源，与一般光源的根本区别是拥有两个方向自由度**

- **物体相对于环境光的移动、缩放可忽略，只需要根据法线方向，“从圆心出发”对环境贴图采样**

- **环境光在一个时刻静态，但会随时间变化而变化**

  - 可以生成一套环境贴图，天空、物体的反射光亮度可以通过简单插值来计算
  - 太阳这样会运动的物体必须特殊处理

### 球谐函数(Spherical Harmonics)

<img src="image-20250206102935725.png" alt="image-20250206102935725" style="zoom:50%;" />

*上面的图形表示球谐函数在各个方位的取值，蓝色表示正数，黄色表示负数，到原点越远，绝对值越大*
$$
\int_{\Omega^{+}} B_l^m(\omega) \mathrm d \omega=\int_0^{2\pi} \mathrm d \theta \int_\frac{-{\pi}}{2}^\frac{\pi}{2} B_l^m(\theta,\phi)\sin \phi \mathrm d\phi \hfill \\
B_l^m(\theta,\phi) = 
\begin{cases}
\sqrt2 K_l^m \cos (m\phi)P_l^m(\cos \phi)  \quad m>0 \\
\sqrt2 K_l^m \sin (-m\phi)P_l^{-m}(\cos \phi)  \quad m<0 \\
K_l^0P_l^0(\cos \phi) \quad m = 0 \\
\end{cases} \hfill \\
其中,P_n(x)=\frac{1}{2^nn!}\frac{\mathrm d^n(x^2-1)}{\mathrm dx^n} (\mathrm{Legendre多项式}) \hfill \\
P_l^m(x)=(-1)^m(1-x^2)^\frac{m}{2}\frac{\mathrm d^m P_l(x)}{\mathrm dx^m} \hfill \\
K_l^m=\sqrt{\frac{2l+1}{4\pi} \frac{(l-|m|)!}{(l+|m|)!}} \hfill \\
\\
B_l^m(\omega)具有以下性质: \hfill \\
① \int_{\Omega^{+}} B_l^m(\omega)B_k^n(\omega) \mathrm d\omega
=\begin{cases}
1 \quad (l = k,且m=n) \\
0 \quad (其他)  \\
\end{cases} \hfill \\
\\
f(\omega) \approx \sum_{l=0}^{b} \sum_{m=-l}^l c_l^mB_l^m(\omega) \hfill \\
其中c_i=\int_{\Omega^{+}} f(\omega)B_i(\omega) \mathrm d\omega,称为f(\omega)在B_i(\omega)上的\textbf{投影} \hfill \\
若还有g(\omega) \approx \sum_{l=0}^{b} \sum_{m=-l}^l d_l^mB_l^m(\omega) \hfill \\
则\int_{\Omega^{+}} f(x)g(x) \mathrm d\omega= \sum_{l=0}^{b} \sum_{m=-l}^l c_l^md_l^m \int_{\Omega^{+}} [B_l^m(\omega)]^2 \mathrm d \omega 
= \sum_{l=0}^{b} \sum_{m=-l}^l c_l^md_l^m
$$

- 一系列定义在球面上的**基函数**（可以转化为球面坐标系下的二元函数），多个基函数组合起来近似表示原函数
- **最重要的性质是正交性，将两个函数均用球谐函数（近似）表示，则可以利用正交性加速计算**
- **原函数旋转后，系数的变化容易计算**
- 第$l$阶有$2l+1$个不同的球谐函数；**阶数越高，频率越高**
- **两函数乘积的频率取决于两函数中频率较低的一个**
  - **只使用前若干阶基函数近似，相当于消除了一定范围内的高频信息**
- **理论上，计算球谐函数系数的方式是，将原函数和各个球谐函数相乘后求积分；而实际上，原函数和各个球谐函数都通过分辨率有限的贴图（通常是立方体贴图）来表示，因此实际计算时变为离散的相乘-求和-取平均**

### 小波变换（？）

- **直接在立方体贴图上，对每个面的纹理近似**
- **能够以较低的成本记录足够高频的信息**
- 得到的结果能较好地反映镜面反射

### Image-Based Lighting

- 预计算渲染方程中的某些中间结果，将结果储存到纹理中，用于简化运算，这种做法即称为Image-Based Lighting
- 常见的两种方法是Reflection Mapping，Diffuse Irradiance Map，分别计算镜面反射环境光和漫反射环境光

#### Reflection Mapping

$$
\underset{env\_specular}{L_r(\mathbf p,\mathbf v)}= \int_{\Omega^{+}} L_r(\mathbf o_e,-\mathbf l)V(\mathbf p,\mathbf l) \frac{D(\mathbf n,\mathbf l)F(\mathbf n,\mathbf l)G(\mathbf v,\mathbf n,\mathbf l)}{4 \ (\mathbf v \cdot \mathbf n)} \mathrm d\omega \hfill \\
\approx L_r(\mathbf o_e,-\mathbf r) \int_{\Omega^{+}} \frac{D(\mathbf n,\mathbf l)F(\mathbf n,\mathbf l)G(\mathbf v,\mathbf n,\mathbf l)}{4 \ (\mathbf v \cdot \mathbf n)} \mathrm d\omega  \hfill \\
\mathbf r:\mathbf v关于\mathbf n的镜面对称方向 \quad L_r(\mathbf o_e,-\mathbf r):沿-\mathbf r射入的环境光亮度 \hfill \\
\\
以\mathrm{Trowbridge-Reitz(GGX)}模型为例: \hfill \\
D(\mathbf n,\mathbf l) = \frac{\alpha^2}{\pi((\mathbf n \cdot \mathbf h)^2(\alpha^2-1)+1)^2} \quad 其中\mathbf h =\frac{ \mathbf l + \mathbf v}{|\mathbf l+\mathbf v|} \hfill \\
F(\mathbf n,\mathbf l) = F_0(\mathbf p) + (1-F_0(\mathbf p))(1 - \mathbf v \cdot \mathbf h)^5 \hfill \\
G(\mathbf v,\mathbf n,\mathbf l) = g(\mathbf l)g(\mathbf v) \quad 其中 g(\mathbf x) = \frac{\mathbf n \cdot \mathbf x}{(1-k)\mathbf n \cdot \mathbf x + k} \quad k = \frac{(\alpha + 1)^2}{8} \hfill \\
\\
注意到:\mathbf v \cdot \mathbf n = \mathbf r \cdot \mathbf n,并认为\mathbf r\cdot \mathbf h \approx \mathbf r\cdot \mathbf n,记\cos \theta = \mathbf r \cdot \mathbf n  \hfill \\
\underset{env\_specular}{L_r(\mathbf p,\mathbf v)}=L_r(\mathbf o_e,-\mathbf r) \int_{\Omega^{+}} \frac{D(\cos \theta,\alpha) [F_0(\mathbf p) + (1-F_0(\mathbf p))(1 - \cos \theta)^5]G(\cos \theta,\alpha)}{4 \cos \theta}\mathrm d\omega \hfill \\
=L_r(\mathbf o_e,-\mathbf r)\left[ F_0(\mathbf p)\int_{\Omega^{+}} \frac{D(\cos \theta,\alpha) [1-(1 - \cos \theta)^5]G(\cos \theta,\alpha)}{4 \cos \theta}\mathrm d\omega+\int_{\Omega^{+}} \frac{D(\cos \theta,\alpha) (1 - \cos \theta)^5G(\cos \theta,\alpha)}{4 \cos \theta}\mathrm d\omega \right] \hfill \\
=L_r(\mathbf o_e,-\mathbf r)\left[F_0(\mathbf p)\int_{\Omega^{+}} g(\alpha,\cos \theta) \mathrm d\omega+\int_{\Omega^{+}} h(\alpha,\cos \theta) \mathrm d\omega  \right]\hfill \\
g,h:只含有\alpha,\cos \theta这两个变量的函数 \hfill \\
$$

- **一种基本的利用环境贴图的方法，只计算镜面反射，且没有考虑可见度**
-  计算一个片元的镜面反射时，简单地认为**各方向的环境光同镜面方向的环境光一致**，以此分离出积分项
  - **远离镜面方向的入射环境光产生的镜面反射光可忽略**，因此产生的误差可接受
  - 由此，原本各方向上采样的问题简化为**只在镜面方向上对环境贴图采样**
  - 先**对环境贴图滤波**，相当于原本单一方向的环境光亮度变为附近区域的平均环境光亮度，这样得到的结果更真实

<img src="image-20250205131614732.png" alt="image-20250205131614732" style="zoom:50%;" />

- **根据对BRDF积分的近似，可以计算两个积分若干离散点的取值，形成LUT，储存成贴图（分别占用r通道和g通道）**
- 总体过程：
  1. 预先将各种$\alpha,\cos \theta$的取值代入积分式，记录积分值，形成LUT
  2. 对环境贴图滤波
  3. 每个片元计算间接光照时，计算**出射方向的镜面对称方向**，根据此方向对环境贴图采样，得到近似的**环境光亮度**
  4. 获取片元的粗糙度、计算镜面方向与法线的夹角，根据这一对值在LUT中查找，得到两个积分项的值
  5. 获取片元的菲涅尔反射率，代入以上各个值即得到镜面反射环境光亮度

#### Diffuse Irradiance Map

<img src="image-20250205135048676.png" alt="image-20250205135048676" style="zoom:50%;" />

*左下图为Diffuse Irradiance Map，左上图为环境贴图*
$$
\underset{env \_ diffuse}{L_r(\mathbf p,\mathbf v)}
=k_d(\mathbf p) E(\mathbf p)\hfill \\
E:环境光在\mathbf p点产生的光照度 \hfill \\
$$

- **只计算漫反射且不考虑可见度时**，不需要考虑入射方向的区别，因而可以预计算各方向环境光照在物体表面各点产生的光照度
- 预计算结果存储在Diffuse Irradiance Map中，它与环境贴图的形状一致
- Diffuse Irradiance Map会随环境贴图的变化而变化
- 总体过程：
  1. 环境贴图变化时，重新生成Diffuse Irradiance Map，并滤波
  2. 每个片元计算间接光照时，根据**法线方向**对Diffuse Irradiance Map采样，得到**环境光光照度**
  3. 环境光光照度与漫反射系数相乘，即得到漫反射环境光亮度

### Light Probe

<img src="image-20240821095317960.png" alt="image-20240821095317960" style="zoom:50%;" />

*Light Probe不是真实存在的物体，不会产生遮挡；完全不会被光照的位置不需要放置Light Probe*

- 对环境贴图的一种改进，不是每个物体记录自身的间接入射光，而是记录空间中许多位置的间接入射光；每个片元不是查询自身所属物体的贴图，而是查询附近若干个Light Probe，然后加权平均
- 总体过程：
  1. 在场景中放置大量Light Probe，通过光线追踪计算反射到其球面上的**间接入射光**结果
  2. 光源或某些物体运动后，更新其附近的Light Probe
     - 更新不需要立即执行，可以延迟以实现负载均衡

  3. **每个物体计算间接光照前，获取离物体最近的几个Light Probe**
  4. **每个片元计算间接光照时，计算出射方向的镜面对称方向，根据此方向在片元所属物体最近的几个Light Probe采样**
     - 常用的权重是片元（的世界坐标）到各Light Probe球心的**距离的反比**

  5. 对采样结果加权平均得到间接入射光亮度，参与间接光照计算
     - 和环境贴图有类似的不精确问题

### PRT(Precomputed Radiance Transfer)

$$
只考虑自遮挡和自反射:L_r(\mathbf p,\mathbf v)= \int_{\Omega^{+}} L(\mathbf o,-\mathbf l) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
L(\mathbf o,-\mathbf l):沿-\mathbf l入射的光线亮度(无自遮挡时,\mathbf o即环境光源\mathbf o_e,有自遮挡时,\mathbf o表示反射源) \hfill \\
\\
L_r(\mathbf p,\mathbf v)=\lim_{i\rightarrow \infty} L_r^i(\mathbf p,\mathbf v) \hfill \\
L_r^i(\mathbf p,\mathbf v):各方向光线经过\textbf{至多}i次反射射到\mathbf p,然后沿\mathbf v方向反射出的光线的亮度 \hfill \\
\\
只考虑环境光直射时:L_r^0(\mathbf p,\mathbf v)=\int_{\Omega^{+}} L(\mathbf o_e,-\mathbf l)V(\mathbf p,-\mathbf l) (\mathbf l \cdot \mathbf n)f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
考虑直射及前i次反射时:L_r^i(\mathbf p,\mathbf v)
=L_r^0(\mathbf p,\mathbf v)+\int_{\Omega^{+}} L_r^{i-1}(\mathbf o,-\mathbf l)[1-V(\mathbf p,-\mathbf l)] (\mathbf l \cdot \mathbf n)f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
V(\mathbf p,-\mathbf l)=0意味着-\mathbf l方向上环境光源被遮挡,同时意味着该方向上有反射源 \hfill \\
\\
记L_r(\mathbf p,\mathbf v)=\int_{\Omega^{+}} L(\mathbf o_e,-\mathbf l)T(\mathbf p,-\mathbf l,\mathbf v) \mathrm d\omega 
\quad (L_r^i(\mathbf p,\mathbf v)不断展开,最终必然包含L(\mathbf o_e,-\mathbf l)项)\hfill \\
L(\mathbf o_e,-\mathbf l)称为\mathrm{Lighting}项,T(\mathbf p,-\mathbf l,\mathbf v)称为\mathrm{Light Transport}项 \hfill \\
\\
仅考虑漫反射时: \hfill \\
L(\mathbf o_e,-\mathbf l) \approx \sum_{i=0}  c_iB_i(\omega) \hfill \\
对于每个顶点(\mathbf n,\mathbf p给定),T(\mathbf p,-\mathbf l) \approx  \sum_{i=0} d_iB_i(\omega)  \hfill \\
\Rightarrow L_r(\mathbf p,\mathbf v) \approx \sum_{i=0} c_id_i \hfill \\
\\
考虑镜面反射时: \hfill \\
对于每个顶点(\mathbf n,\mathbf p给定),T(\mathbf p,-\mathbf l,\mathbf v) \approx  \sum_{i=0} d_iB_i(\omega,\mathbf o) \approx \sum_{i=0} \left[ d_i\sum_{j=0}e_jB(\omega) \right] \hfill \\
\Rightarrow L_r(\mathbf p,\mathbf v) \approx \sum c_id_i \hfill \\
$$

*可以将Lighting项的基函数表示代入积分，相当于将各个基函数看作光照函数*

- **一种预计算间接光照的方法，环境光为入射光，计算环境光直射和内反射的结果（不计算不同物体间的反射）**
  - 介于环境映射和全局光照之间的算法（比一般的环境映射多考虑了内反射）

| 函数                                       | 自变量                                    | 储存函数所需的资源                                       |
| ------------------------------------------ | ----------------------------------------- | -------------------------------------------------------- |
| $L(\mathbf o,-\mathbf l)$                  | $\mathbf l$                               | **一个向量（即球谐函数的系数）**                         |
| $T(\mathbf p,-\mathbf l)$ (忽略镜面反射项) | $\mathbf l,\mathbf p,\mathbf n$           | **每个顶点一个向量**                                     |
| $T(\mathbf p,-\mathbf l,\mathbf v)$        | $\mathbf l,\mathbf v,\mathbf p,\mathbf n$ | **每个顶点一个矩阵（两次近似中球谐函数的系数组合相乘）** |

*实际着色中，使用颜色而非亮度，RGB通道单独计算，因此一组系数变为三组*

- **将积分项分为Lighting项和Light Transport项**
  - **Lighting项就是环境贴图表示的函数，LightTransport项表示光线多次反射的结果(最后的射出方向也要考虑)**
  - **给定了顶点坐标、法线后，LightTransport项才成为一元或二元函数**

<img src="image-20250624130654863.png" alt="image-20250624130654863" style="zoom:50%;" />

*用不同数量(阶数)的基函数近似环境光，分别还原出环境贴图*

![image-20250701141005378](image-20250701141005378.png)

*考虑镜面反射时，Light项向量与Transport项矩阵相乘，得到一个向量（依然是球谐函数的系数）；上图中，向量为9维，因为使用3阶共9个球谐函数*

- **物体旋转时LightTransport项会改变（平移和缩放显然不影响LightTransport项），而旋转导致的基函数系数变化容易计算**
- **总体过程：**
  1. **根据环境贴图，用球谐函数近似Lighting项，记录各基函数系数**
  2. **对于每个物体的每个顶点，根据物体的性质和材质，计算出只考虑直射时的LightTransport项，用球谐函数近似（计算方式和Light项相同）**
  3. **递归地计算多考虑一次内反射后的LightTransport项，直到达到预设的计算次数，然后将系数矩阵记录在VBO中**
  4. **运行时，对于每个片元，对所属三角形面三个顶点的矩阵插值，得到片元的矩阵**
  5. **LightTransport项系数与Lighting项系数的乘积即反射光**
     - **不考虑镜面反射时，向量乘向量得到一个唯一值，各方向反射光亮度均为此值**
     - **考虑镜面反射时，向量乘矩阵得到一组球谐函数系数，将观察方向代入球谐函数得到亮度值**
- **近似时，通常使用前3或4阶的球谐函数；镜面反射光的（信号）频率很高，用PRT难以准确表现**

## 全局光照

$$
\underset{indirect}{L_r(\mathbf p,\mathbf v)}= \int_{\Omega^{+}} L_r(\xi,-\mathbf l) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
L_r(\xi,-\mathbf l):所有沿-\mathbf l射到\mathbf p的光线的总亮度 \quad \mathbf o:反射源 \hfill \\
$$

- 主要目标是计算直接光照和直接光照后**第一次反射**的结果
  - 通常只计算**一般光源**在各物体间的反射，与环境映射是独立的
  - 计算得到的亮度值通常与直接光照和环境光照相互独立
- **主要难点在于如何在计算每个片元的光照时，向半球面各个方向采样（而不是仅考虑光源方向）**


### Reflective Shadow Mapping

<img src="image-20250728104450128.png" alt="image-20250728104450128" style="zoom:50%;" />
$$
\underset{indirect}{L_r(\mathbf p,\mathbf v)}= \int_{\Omega^{+}} L_r(\xi,-\mathbf l) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\ 
考虑所有次级光源:\underset{indirect}{L_r(\mathbf p,\mathbf v)}=\int_A L_r(\mathbf q,-\mathbf l) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \frac{\mathrm dA}{(\mathbf p-\mathbf q)^2} \hfill \\
\\
第一次反射只考虑漫反射,故L_r(\mathbf q,-\mathbf l)=E(\mathbf o,\mathbf q)k_d(\mathbf q) \hfill \\
注意到E=\frac{\mathrm d\Phi}{\mathrm dA},并随机采样:
\underset{indirect}{L_r(\mathbf p,\mathbf v)}= \frac{k}{n} \sum_{i=1}^n  \frac{\Delta\Phi(\mathbf o,\mathbf q_i)k_d(\mathbf q_i) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v)}{(\mathbf p-\mathbf q)^2} \hfill \\
\Delta\Phi(\mathbf o,\mathbf q_i):光源\mathbf o在\mathbf q_i处产生的光通量(要考虑第一次照射角) \hfill \\
$$

- **只考虑一次反射**，将所有被光源直射的区域也视为**次级光源**，属于**虚拟点光源(VPL)**方法
  - 使用一个**RSM纹理**，在Shadow Map记录到光源距离基础上，额外记录**观察空间坐标、光源在此处产生的光通量、此处法线方向**
  - 光源与表面各处的可见性不用单独计算，因为**RSM中的纹素必然表示被光源直射的表面**
  - 次级光源与片元间的可见性难以计算，直接认为全部完全可见（会导致不真实）
  - 一个区域作为间接光源时，简单地认为它朝各个方向发射的光线强度相同，即只考虑漫反射（计算片元的光照时，还是照常计算镜面反射）
- **理想情况下，对每个片元着色时，要计算所有次级光源的贡献，而实际渲染时只能在一定范围内采样**
  - **在RSM纹理中采样，得到次级光源的光照强度、法线方向；如果着色点并不位于次级光源的上半球面内，次级光源贡献为0**
- 总体过程：
  1. 对于每个产生阴影的光源，额外使用一个Pass（RSM Pass），每个Pass的渲染结果为一个RSM纹理
  2. 对于每个片元，向片元着色器输入各个RSM纹理及对应的光源矩阵
  3. 根据光源矩阵，计算片元到光源的深度，以及在RSM纹理中的坐标
  4. 在一定范围内采样Shadow Map，计算直接光照可见度(参考PCF)
  5. **在一定范围内采样Shadow Map，根据纹素记录的观察空间坐标、光通量、法线方向计算次级光源对片元的光照值**
- 类似Shadow Map，**光源数量的增加**和**照射范围的扩大**会显著增加时间成本
- **易于实现，但真实性一般**

### Light Propagation Volume

<img src="image-20250807145714957.png" alt="image-20250807145714957" style="zoom:50%;" /><img src="image-20250807151001142.png" alt="image-20250807151001142" style="zoom: 67%;" />

- 将整个场景均匀划分为粒度较大的网格，用于计算光线传播
- 总体过程：
  1. 渲染**RSM纹理**
  2. 使用一个3D纹理来记录整个场景，确定世界空间坐标到纹理坐标的映射
  3. 对于RSM纹理中的每个纹素，根据其世界空间坐标确定其所属的纹素，在该纹素中记录次级光源向各个方向发出光线的亮度
     - 考虑镜面反射，因此并非各向同性
     - 用球谐函数来近似表示各方向光线亮度（通常仅使用前2阶，共4个系数，恰好作为一个颜色值写入纹理）
     - 次级光源总是被认为处于所属网格的中心，带来位置上的误差
  4. 从所有次级光源出发，模拟光线传播，更新每个纹素中记录的球谐函数系数
     - 每次向相邻的六格传播，计算穿过接触面的光线（？）
     - **传播时不考虑物体遮挡**（类似RSM）
  5. 对于每个片元，确定其所属的网格，将该网格记录的球谐函数视为各方向的间接光照，据此直接计算间接光照反射后结果
     - 用球谐函数表示余弦项和BRDF项的乘积（类似LightTransport项），然后两组系数直接相乘得到结果
     - 由于之前产生的位置上的误差，这一步着色时可能出现不真实的透光现象

### Voxel Global Illumination

- 类似Light Propagation Volume，但计算光线传输时更复杂（？）

### 环境光遮蔽(Ambient Occlusion)

$$
\underset{indirect}{L_r(\mathbf p,\mathbf v)}= \int_{\Omega^{+}} L_r(\mathbf o,-\mathbf l)V(\mathbf p,\mathbf l) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
L_r(\mathbf o,-\mathbf l):从\mathbf o向-\mathbf l反射的光线亮度 \quad
\mathbf o:反射源 \quad V(\mathbf p,\mathbf l):从\mathbf p出发,\mathbf l方向上的可见度 \hfill \\
L_r(\mathbf o,-\mathbf l)为常数,仅计算漫反射: 
\underset{indirect}{L_r(\mathbf p,\mathbf v)}=k_d(\mathbf p)L \int_{\Omega^{+}} V(\mathbf p,\mathbf l) (\mathbf l \cdot \mathbf n) \mathrm d\omega \approx k(\mathbf p)\int_{\Omega^{+}} V(\mathbf p,\mathbf l) \mathrm d\omega \hfill \\
$$

- **在屏幕空间近似地模拟物体间遮蔽的影响**
  - 认为**光均匀地从适当远处沿半球面各方向射入**（适当远不是无穷远；比如，物体和光源都在完全封闭空间内，这种情况下物体仍然应该能接收到间接光照；具体实现时，这一距离体现为采样范围）
  - AO仅反映了**来自远处的间接光照**
  - 理论上，考虑到入射角，不同方向的入射光贡献不同；而实际计算时经常忽略
  - 计算片元反射时，不考虑镜面反射项

- 深度缓冲属于屏幕空间，根据各位置不同的深度值，可以构造出一个三维空间（类似于立方体积木，以下称为**“积木空间”**）
  - 深度缓冲是场景局部的近似表示（不仅是精度降低，还消除了沿镜头方向的中空结构）
  - 要判断某一点是否位于积木内部，只要求这一点的带深度的屏幕坐标，然后与深度缓冲中记录的值比较

$$
环境映射:\underset{env}{L_r(\mathbf p,\mathbf v)}= \int_{\Omega^{+}} L_r(\mathbf o_e,-\mathbf l)V(\mathbf p,\mathbf l) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
\approx \overline{V(\mathbf p)}\int_{\Omega^{+}} L_r(\mathbf o_e,-\mathbf l)(\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
\mathbf o_e:\textbf{充分远处}的环境光源 \hfill \\
$$

- **环境光遮蔽的计算结果，可以用作环境映射中的可见度**


#### Screen Space Ambient Occlusion

$$
\int_{\Omega^{+}} V(\mathbf p,\mathbf l)\mathrm d \omega=\frac{M}{N} \hfill \\
N:采样点总数 \quad M:不处于积木内部的采样点总数
$$

- 在积木空间中，在某片元处的**上半球面**内取若干个采样点，判断其是否位于积木内部
  - 获取片元的观察空间坐标、法线，然后在观察空间内取采样点，然后将采样点坐标转换回带深度的屏幕空间坐标

- 可以让采样方向随空间（片元屏幕坐标）和时间变化，然后滤波

#### Horizon-Based Ambient Occlusion

$$
\int_{\Omega^{+}} V(\mathbf p,\mathbf l)\mathrm d \omega=\frac{1}{n} \sum_{i=1}^n \left[1-\frac{\theta_i}{\pi/4} \right] \hfill \\
\theta_i:第i个方向上积木遮挡光线的角度
$$

- 在积木空间中，以某片元为中心，在XY平面内发射若干条射线，计算各方向上积木（从地平线往上）遮挡光线的角度
- 可以让采样方向随空间（片元屏幕坐标）和时间变化，然后滤波


#### 环境光遮蔽贴图

- 将物体表面预计算好的（平均）间接光照可见度存在纹理中
- **仅考虑自身对自身的遮蔽**，不考虑其他物体，适用于有明显凹凸的物体

### Screen Space Directional Occlusion

<img src="image-20250811170104496.png" alt="image-20250811170104496" style="zoom:50%;" />

*左1的渲染结果较好，但随着黄色物体转向屏幕中基本看不见的方向，其反射到地面的光也不再被渲染*

<img src="image-20250811142120945.png" alt="image-20250811142120945" style="zoom:50%;" />

*上图为世界空间的截面，积木空间应当是长方体而非锥体；左上图中，A,B,D点被认为会向P点反射射线*
$$
\underset{indirect}{L_r(\mathbf p,\mathbf v)}= \int_{\Omega^{+}} L_r(\mathbf q,-\mathbf l)[1-V(\mathbf p,\mathbf l)] (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v) \mathrm d\omega \hfill \\
L_r(\mathbf q,-\mathbf l):从\mathbf q向-\mathbf l反射的光线亮度 \quad
\mathbf q:反射源 \quad V(\mathbf p,\mathbf l):从\mathbf p出发,\mathbf l方向上的可见度 \hfill \\
\\
随机采样:\underset{indirect}{L_r(\mathbf p,\mathbf v)}= \frac{k}{n} \sum_{i=1}^n  \frac{\Delta\Phi(\mathbf o,\mathbf q_i)k_d(\mathbf q) (\mathbf l \cdot \mathbf n) f(\mathbf p,\mathbf l,\mathbf v)}{(\mathbf p-\mathbf q)^2} \hfill \\
\Delta\Phi(\mathbf o,\mathbf q_i):光源\mathbf o在\mathbf q_i处产生的光通量(要考虑第一次照射角) \hfill \\
$$

- 同样在积木空间内进行计算，但假设与AO不同，认为某片元的上半球面内，**只有积木表面才会向片元反射光线**
  - 采样点限制在在片元的一定距离内，因此SSDO仅反映了**来自近处的间接光照**
- 类似RSM，有**次级光源**的概念，第一次反射时仅考虑漫反射，但在屏幕空间而非光源空间进行，因此要配合**延迟渲染**使用
  - 直接从G-Buffer获取法线，需要额外使用一个缓冲区记录观察空间坐标
  - **漫反射缓冲中记录的亮度与片元接收的光通量×片元漫反射系数成正比**
  - 在屏幕空间计算会导致**无法计算不出现在屏幕中的物体的反射光**
- SSDO的结果也可以用于环境映射中的可见度（非必须）
- 总体过程：
  1. 初步渲染出G-Buffer中的各个缓冲区（这一步仅得到直接光照结果）
  2. 计算一个片元的间接光照时，获取其法线、观察空间坐标
  3. 在观察空间内，在片元的上半球面内取若干个采样点
  4. 对于每个采样点，计算其屏幕空间坐标，如果其深度小于深度缓冲记录的深度（在积木外部），直接忽略
  5. 获取采样点对应片元的法线，计算观察空间坐标，如果被着色片元不在采样片元的上半球面内，直接忽略
  6. 获取采样片元的漫反射亮度，据此计算其对着色片元的间接光照贡献

### Screen Space Reflection

<img src="image-20250812145134117.png" alt="image-20250812145134117" style="zoom:50%;" />

- 类似RSM，有**次级光源**的概念，但在屏幕空间而非光源空间进行，因此要配合**延迟渲染**使用
- 总体过程：
  1. 初步渲染出G-Buffer中的各个缓冲区（这一步仅得到直接光照结果）
  2. 计算一个片元的间接光照时，获取其法线、观察空间坐标
  3. 在观察空间内，计算观察方向的镜面方向，沿该方向步进，取得一系列采样点
  4. 计算各采样点的带深度屏幕空间坐标，判断其Z分量是否小于深度缓冲记录的深度，如果小于，说明采样线已经从外穿进表面，停止步进，最后一个点对应的片元即反射源
  5. 获取反射源的法线，计算其观察空间坐标，如果被着色片元不在采样片元的上半球面内，直接忽略
  6. 根据最后一个点的屏幕空间坐标，读取该位置直接光照颜色，即反射颜色
- 与SSDO类似，只是用沿直线采样代替了散布采样点
  - 同样**无法计算不出现在屏幕中的物体的反射光**


### 光照贴图

<img src="image-20240821093623923.png" alt="image-20240821093623923" style="zoom:50%;" />

*场景中所有物体的所有表面的着色结果统一记录在一张贴图上；不是平面投影，而是包含所有物体的所有表面*

- 使用贴图记录**整个场景**的**静态光照结果**（运行时计算动态光照）
  - 由**预计算（光栅化渲染管线难以计算，通常使用光线追踪计算）**生成
  - **作用于片元着色计算阶段，对此贴图采样直接得到静态光照结果**


# 后处理

## FXAA？

