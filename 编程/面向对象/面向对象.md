# 概念

## 对象

对象是数据和操作的集合。常见语言中，变量、实例等都属于对象

## 封装

- 隐藏对象的属性和实现细节，对外提供API


- 提高代码的可靠性、易用性


## 继承

- 用简单的语法来表示“把某个类（父类）非私有成员复制过来”，并允许在此基础上重写
- 减少重复代码，提高复用性，且共通的部分可以统一修改
- 很多时候使用组合更好
- 允许继承这一点损失了一定的封装性

## 多态

- 同一个类型的对象的同名行为可能代表不同的实现
- 减少结构相同（功能相同，参数不同）的代码，提高复用性和可拓展性

### 分类

- 静态多态：编译时确定的多态，如方法重载
- 动态多态：运行时确定的多态，如方法重写

### 重载/重写/隐藏

- 重载：同名而参数列表不同的方法会发生重载。包括同一个类中的同名不同参方法和父类与子类的同名不同参方法

- 重写：同名且参数列表相同的方法会发生重写。子类方法可以重写父类方法。如果某对象在创建时是子类，且重写了父类的方法，那么无论它被赋值给什么类型的字段，调用该方法时都会调用子类中的方法
- 隐藏：同名且参数列表相同的方法会发生隐藏。子类方法可以隐藏父类方法。调用哪个方法取决于该实例被赋值给什么类型的字段，变量，变量类型是什么，就调用该类型的该方法

### 协变逆变不变

协变、逆变、不变用于描述**包含泛型的类型**之间的关系。

- 协变：子类泛型赋值给父类泛型。如`IEnumarable<string>` 可赋值给`IEnumrable<object>`。(能输出子类，就能输出父类)


- 逆变：父类泛型赋值给子类泛型。如`Action<object>`可赋值给`Action<string>`。(能接受父类，就能接受子类)


- 不变：父子类泛型无法相互赋值。如`IList<string>`和`IList<object>`不能相互赋值。(既要输入，又要输出)

## 访问修饰符

**访问方法/字段的行为必然发生在方法中**

**public方法/字段**：任何类的方法可以访问

**protected方法/字段**：本类的方法可以访问；子类的方法中，仅可以通过其自身的类的实例访问该方法/字段（将子类记为B父类记为A，B可以通过其自身实例访问A的方法/字段，B也可以创建另一个B类实例，然后通过创建出的实例访问A的方法/字段，但不能通过创建出来的A类实例或者A的其他子类的实例，访问A的方法/字段）

**private方法/字段**：只有本类的方法可以访问

## 类

### 构造函数

存在继承时，从最高级父类到子类按顺序调用构造函数。父类存在无参构造函数时，默认调用无参构造函数，也可以显式调用其他构造函数；不存在时，则必须显式调用父类的一个有参构造函数，**即使子类构造函数参数列表与父类一致**(否则程序不知道如何构造父类)。

# 编程原则

## 开闭原则

- 软件应当对拓展开放，对修改关闭。即理想的代码应当实现，增加新的功能时，不需要修改关于就功能的代码

## 单一职责原则

- 一个对象应该仅包含单一的职责
- 对类功能的拆分有利于复用、降低耦合、独立控制、排查错误
- 对类功能的拆分应当适度，过度拆分不利于管理。如果一些功能总是关联在一起，则不必拆分

## 里氏替换原则

- 程序中，子类总是可以充当其父类来使用。即子类不能改变父类原有的行为（依然可以拓展行为），重写时尽量不要舍弃父类原本的实现

## 接口隔离原则

- 一个接口应该仅包含单一的职责
- 对接口的拆分有利于充分使用接口、减少无用实现、降低耦合

## 迪米特法则

- 尽量阻止无关的类之间相互访问，尽量将类之间的信息传递降低到最小限度
- 可以引入中介类，来将直接信息传递转为间接信息传递，引入中介类有利有弊。通常，两个类不属于同一个功能模块时，会考虑使用中介类

## 依赖倒置原则

- 程序要依赖于接口，而不依赖于具体实现。即理想的程序，其要实现的具体功能改变时，底层抽象不需要改变（比如尽量避免在父类中判断某个输入的对象到底是哪个子类）
- 依赖倒置存在广泛、形式多样。总体来说，就是尽量避免将某个功能写死，而是为其添加一层抽象，以减少具体实现的改变产生的连带修改

## 合成复用原则

- 优先考虑使用组合来实现复杂功能，而不是继承
- 不会破坏对象的封装性，使用灵活

## 依赖注入

- 对象A依赖另一个对象B时，A不主动创建或获取B，由第三者来控制A如何获取B
- 依赖的对象的类型可能会改变，如果直接把依赖的对象创建出来，之后要被迫要修改创建对象的代码；更好的做法是使用接口代替具体类型，具体类型改变时，接口和调用接口的方法不用修改
- 依赖注入适用于依赖的对象的具体类型可能会改变的情况，不要滥用

# 设计模式

## 单例模式

- 确保一个类全局只能同时存在一个实例，且该实例全局可访问
- 获取对象的时机和手段应当被充分限制，基本的单例模式不够灵活

## 工厂模式

- 要构造对象时，不直接调用构造函数，而是使用工厂方法来代替。需要同类对象时，调用相同的工厂方法，工厂方法可以统一修改，体现了依赖倒置原则
- 工厂方法可以包含参数，但这样通常反而会违反依赖倒置原则和开闭原则
- 可以定义抽象工厂并继承

## 装饰器模式

- 希望拓展一个类的功能，但又不希望添加新的子类时，可以添加装饰器类。装饰器类持有被装饰类，并包含额外的方法
- 被装饰类往往是抽象类，装饰类也可以是抽象类，可以继续继承

## 适配器模式

- 原本写好的一些接口和类，在新的环境中可能无法使用，可以新建一个适配器，持有原有类，同时实现新环境中规定的接口
- 适配器是让现有功能适应新环境，从头设计新功能时不会用到适配器模式
- 适配代价过大时，应当重构原有代码

## 外观模式

- 为了实现一个功能，可能会先后调用系统中的各种方法。可以将这一过程合并到一个函数中，以方便调用
- 仅仅是为了开发者或使用者的方便，对系统本身没有任何好处

## 代理模式

- 要访问一种对象时，不直接访问，而是经由代理类间接访问（代理类持有原类）
- 代理类在访问原类前后，可以执行一些额外的行为。某些情况下，直接访问原类可能会带来问题。如果这种情况普遍，可以添加一层代理层来处理，以免每次访问时手动执行额外行为

## 命令模式

- 将对象的某些行为抽象成命令
- 命令可以执行/撤销，可以形成日志/回放
- 输入到命令的映射可以修改（如修改按键绑定）。注意，输入事件和命令未必是一一对应的

## 策略模式

- 使用包含方法的类/接口或委托来代替一个固定的方法，使对象的行为可变
- 类似组件模式，粒度更小

## 桥接模式

- 一个类的两个部分均有可能发生变化，可以将它们分别抽象，不需要排列组合定义大量子类
- 和组件模式的主要区别在于，两个部分并不是独立工作、毫无关系的，其中一个部分可能会以另一部分为参数

## 观察者模式

- 对象间的信息传递广泛存在。将信息发出者称为被观察者，信息接收者称为观察者
- 可以将”被观察者逐个访问观察者“改为”被观察者持有一个观察者列表，观察者主动将自身添加到列表/从列表移除“。这样可以避免观察者被删改时，被观察者被迫跟着改
- 可以进一步引入中介，记录观察者列表，传递信息
- 如果两个对象的联系非常紧密，没必要使用观察者模式（如，同一功能模块下的两个对象；总是同时存在且相互关联的两个对象）

## MVC

- Model：定义数据，以及相关的行为
- View：定义与外观有关的方法，在这些方法中控制UI；检测来自UI的输入，并传递给Controller
- Controller：处理用户输入；根据用户输入和其他条件，获取/修改Model数据，调用View中相应的方法并传递参数

# 并发编程

## 线程和进程