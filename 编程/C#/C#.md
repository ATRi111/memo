# Common Language Runtime

- CLR，即公共语言运行时，是一个可由多种面向CLR的编程语言使用的“运行时”，包括内存管理、程序集加载、安全性、异常处理和线程同步等核心功能

## 内存管理

### 基础知识

- 每个进程的虚拟地址空间独立（通常是等大的，取决于计算机位数）
- 进程是程序的实例，所以一个正在运行的程序只能使用其自身进程的虚拟内存
- 垃圾分配管理虚拟内存，不会直接控制物理内存
- 虚拟内存块有三种状态：
  - 可使用：没有引用关系，可以被分配
  - 保留：提交的前一步。已经被占用，无法被分配给其他对象，但还不能存储数据
  - 已提交：可以存储数据
- 托管堆：CLR维护的用于管理引用类型对象的堆
- 非托管堆：约等于”本机堆“，需要手动释放资源（非托管堆中的对象通常与操作系统关系密切）

### 托管堆

- 一个进程开始运行后，CLR初始化垃圾回收器，然后分配一段内存作为托管堆
- 每个进程有独立的托管堆，进程中的线程共享托管堆
- 当触发垃圾回收时，垃圾回收器将回收由非活动对象占用的内存
- 空余的内存总量达到一定值时，会发生压缩
- 大型对象被独立保存在大型对象堆中，释放大型对象通常不会引发压缩

### 内存分配

- 初始化新进程时，会创建被称为托管堆（由内存管理器托管的堆区域）的连续内存区域（可以逐渐扩张）
- 所有引用类型（类中的数据和指针）被储存在托管堆中
- 托管堆维护着一个指针，用它指向下一个可用地址（一开始指向托管堆的基址）。每次分配新的引用类型时更新，如此连续分配下去
- 从托管堆中分配内存要比非托管内存分配速度快，且几乎和栈区一样快

### 垃圾回收

- 垃圾回收器会释放应用程序不再使用的内存

- 回收不会在对象不再使用后立即发生，时机与运行情况有关：

  - 可用物理内存较少时
  - 托管堆中的对象占用的空间超过了阈值时
  - 手动调用`GC.Collect`时
- 回收步骤（以一代为单位）：

  1. CLR在进程的某个线程上运行垃圾回收，并暂时挂起其他线程

  2. CLR遍历堆中所有对象，将其暂时标记为**不可达**

  3. CLR确定所有**根**，通过根获取所有可达对象，将其标记为**可达**
  4. 释放不可达对象，更新根指向对象的地址（提前确定目标地址并更新，否则引用会丢失），然后压缩可达对象
  5. 更新下一个可用地址指针

### 幸存和提升

- 托管堆中的对象被分为三代：第0、1、2代。大型对象堆也被称为第3代
- 每一代占用独立的存储空间，未必同时进行垃圾回收

- 第0代：包含短生存期对象
  - 新分配的类实例会成为第0代
  - 分配的大对象会被移至大对象堆
  - 完成垃圾回后，幸存的对象会移动到第1代，临时变量不可能幸存，故第0代中以临时变量为主

- 第1代：短生存期对象和长生存期对象的缓冲区
  - 完成垃圾回后，幸存的对象会移动到第2代

- 第2代：长生存期对象
  - 未被回收的对象回留在第二代
  - 第3代对象总是伴随第2代对象进行垃圾回收

- 正常情况下，进行某代的垃圾回收时，总是伴随着对更年轻的代的垃圾回收，所以越年轻的代，垃圾回收越频繁
- 因为空间满导致垃圾回收时，为了给幸存的对象腾出空间，会从最老的一代开始，到空间满的那一代，依次进行垃圾回收

## 排序

重写CompareTo时，自身减对方为升序；重写Compare时，x-y为升序

# 访问修饰符

## 特有修饰符

**internal**：同一程序集中的**方法**可以访问

**protected internal**：同一程序集中的**方法**，或其他程序集的子类的方法通过该子类的实例可以访问

## 默认修饰符

| 种类                   | 默认修饰符 | 限制                     |
| ---------------------- | ---------- | ------------------------ |
| 命名空间下的类         | public     | public或internal         |
| 类的成员（包括内部类） | private    | 无                       |
| 接口                   | public     | 只能是public             |
| 枚举                   | public     | 只能是public             |
| 结构体                 | private    | private,internal或public |

# 类

## 值类型和引用类型

- struct均为值类型，class均为引用类型


- 引用类型间用等号赋值时，传递的是实例的引用(而不是复制字段或调用拷贝构造函数)。但是，在方法内构造实例并将其返回时仍会引发额外的拷贝和垃圾回收，最好在函数外部构造好再传入(尤其是数组)。


- string类中的字符串实际上是不可变的，每次修改时都会生成新对象，频繁修改时应使用StringBuilder类。string类依然是引用类型，传参时依然是传地址


## 静态构造函数

静态构造函数在第一次访问该类时执行

## 结构体

### 特性

- 不能继承
- **struct间相互赋值时会拷贝各个成员，而不是单纯拷贝地址**（所以赋值的开销高）
- **内存分配到栈而不是堆上**（所以GC的开销低）
- 结构体要求所有字段都显初始化，而类会自动初始化未被初始化的字段
- 将struct赋值给class变量会发生装箱

### 使用技巧

- 不需要继承的、会频繁GC的类适合改成结构体

## 委托

### 特点

- 委托的值为null时即可使用。因此，作为字段的委托不需要初始化（作为本地变量的委托需要赋初值null）
- 当且仅当两个方法引用是同一实例的同一方法（或同一类的同一静态方法）时，两方法引用相等
- 当且仅当两个委托的方法引用相同（顺序和内容都相同）时，两个委托相等（且具有相同的哈希码）
- 委托中可以存在多个相同的方法，删除该方法时删除**最晚加入**的方法
- 底层是函数指针数组，插入的时间复杂度为O(1)，调用的时间复杂度为O(N)，删除的时间复杂度为O(N)



