# Common Language Runtime

- CLR，即公共语言运行时，是一个可由多种面向CLR的编程语言使用的“运行时”，包括内存管理、程序集加载、安全性、异常处理和线程同步等核心功能

## 内存管理

### 基础知识

- 每个进程的虚拟地址空间独立（通常是等大的，取决于计算机位数）
- 进程是程序的实例，所以一个正在运行的程序只能使用其自身进程的虚拟内存
- 垃圾分配管理虚拟内存，不会直接控制物理内存
- 虚拟内存块有三种状态：
  - 可使用：没有引用关系，可以被分配
  - 保留：提交的前一步。已经被占用，无法被分配给其他对象，但还不能存储数据
  - 已提交：可以存储数据
- 托管堆：CLR维护的用于管理引用类型对象的堆
- 非托管堆：约等于”本机堆“，需要手动释放资源（非托管堆中的对象通常与操作系统关系密切）

### 托管堆

- 一个进程开始运行后，CLR初始化垃圾回收器，然后分配一段内存作为托管堆
- 每个进程有独立的托管堆，进程中的线程共享托管堆
- 当触发垃圾回收时，垃圾回收器将回收由非活动对象占用的内存
- 空余的内存总量达到一定值时，会发生压缩（减少碎片）
- 大型对象被独立保存在大型对象堆中，释放大型对象通常不会引发压缩

### 内存分配

- 初始化新进程时，会创建被称为托管堆（由内存管理器托管的堆区域）的连续内存区域（可以逐渐扩张）
- 所有引用类型（类中的数据和指针）被储存在托管堆中
- 托管堆维护着一个指针，用它指向下一个可用地址（一开始指向托管堆的基址）。每次分配新的引用类型时更新，如此连续分配下去
- 从托管堆中分配内存要比非托管内存分配速度快，且几乎和栈区一样快

### 垃圾回收

- 垃圾回收器会释放应用程序不再使用的内存

- 回收不会在对象不再使用后立即发生，时机与运行情况有关：

  - 可用物理内存较少时
  - 托管堆中的对象占用的空间超过了阈值时
  - 手动调用`GC.Collect`时
- 回收步骤（以一代为单位）：

  1. CLR在进程的某个线程上运行垃圾回收，并暂时挂起其他线程

  2. CLR遍历堆中所有对象，将其暂时标记为**不可达**

  3. CLR确定所有**根**，通过根(递归地)获取所有可达对象，将其标记为**可达**
  4. 释放不可达对象，更新根指向对象的地址（提前确定目标地址并更新，否则引用会丢失），然后压缩可达对象
  5. 更新下一个可用地址指针
- 并没有用到引用计数器，因此循环引用也不会导致内存泄漏

### 幸存和提升

- 托管堆中的对象被分为三代：第0、1、2代。大型对象堆也被称为第3代
- 每一代占用独立的存储空间，未必同时进行垃圾回收

- 第0代：包含短生存期对象
  - 新分配的类实例会成为第0代
  - 分配的大对象会被移至大对象堆
  - 完成垃圾回后，幸存的对象会移动到第1代，临时变量不可能幸存，故第0代中以临时变量为主

- 第1代：短生存期对象和长生存期对象的缓冲区
  - 完成垃圾回后，幸存的对象会移动到第2代

- 第2代：长生存期对象
  - 未被回收的对象回留在第二代
  - 第3代对象总是伴随第2代对象进行垃圾回收

- 正常情况下，进行某代的垃圾回收时，总是伴随着对更年轻的代的垃圾回收，所以越年轻的代，垃圾回收越频繁
- 因为空间满导致垃圾回收时，为了给幸存的对象腾出空间，会从最老的一代开始，到空间满的那一代，依次进行垃圾回收

# 关键字

## 访问修饰符

**internal**：同一程序集中的**方法**可以访问

**protected internal**：同一程序集中的**方法**，或其他程序集的子类的方法通过该子类的实例可以访问

| 种类                   | 默认修饰符 | 限制                     |
| ---------------------- | ---------- | ------------------------ |
| 命名空间下的类         | public     | public或internal         |
| 类的成员（包括内部类） | private    | 无                       |
| 接口                   | public     | 只能是public             |
| 枚举                   | public     | 只能是public             |
| 结构体                 | private    | private,internal或public |

# 类

- class均为引用类型；引用类型间使用**等号运算符**或**传递参数**时，总是浅拷贝（仅复制地址）
- **返回值为方法内部构造的实例**时仍会引发额外的拷贝和垃圾回收，最好在函数外部构造好再传入(尤其是数组)
- **string**是特殊的引用类型，使用**等号运算**符时，总是构造新的对象并进行**深拷贝**（传参时依然传地址，但这并不意味着可以在方法中修改外部字符串，除非改为传引用）
- 类或结构体的某个成员是类实例时，该成员**默认被初始化为nullptr**

# 结构体

- struct均为值类型；值类型间使用**等号运算符**或**传递参数**时，总是进行**深拷贝**（构造新对象，拷贝每个成员）
  - 具体到成员字段，class成员总是被浅拷贝，struct成员总是被深拷贝

- 不能继承，（C#10之前）不能定义构造函数，不能设定成员初始值
- 类或结构体的某个成员是类实例时，该成员**默认被初始化为nullptr**
- **内存分配到栈而不是堆上**（所以GC的开销低）；编译器自动进行拷贝，确保数据的生命周期正确”延续“
- 类或结构体的某个成员是结构体实例时，**自动构造该成员**
- 将struct赋值给class变量会发生**装箱**

## 委托

### 特点

- 委托的值为null时即可使用。因此，作为字段的委托不需要初始化（作为本地变量的委托需要赋初值null）
- 当且仅当两个方法引用是同一实例的同一方法（或同一类的同一静态方法）时，两方法引用相等
- 当且仅当两个委托的方法引用相同（顺序和内容都相同）时，两个委托相等（且具有相同的哈希码）
- 委托中可以存在多个相同的方法，删除该方法时删除**最晚加入**的方法
- 底层是函数指针链表，插入的时间复杂度为O(1)，调用的时间复杂度为O(N)，删除的时间复杂度平均为O(N)

# API

## IComparable

- 实现CompareTo时，自身减对方为升序

## Comparer

- 实现Compare时，x-y为升序
